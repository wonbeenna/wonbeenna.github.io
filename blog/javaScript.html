<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/0e4fe491bf84089c-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/627622453ef56b0d-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/7d8c9b0ca4a64a5a-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/8db47a8bf03b7d2f-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/934c4b7cb736f2a3-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/48ff91835f2990e0.css" data-precedence="next"/><link rel="preload" href="/_next/static/chunks/webpack-891dab1a18c2720c.js" as="script" fetchPriority="low"/><script src="/_next/static/chunks/fd9d1056-23f6e37ad1d1612c.js" async=""></script><script src="/_next/static/chunks/864-8d9b6481be2de97f.js" async=""></script><script src="/_next/static/chunks/main-app-a9556013570ce939.js" async=""></script><link rel="preload" href="https://www.googletagmanager.com/gtag/js?id=G-LFDRQZPCBN" as="script"/><title>Been blog - javaScript</title><meta name="description" content="Been dev-note"/><meta name="google-site-verification" content="BirkRt7C7FYMLW96RbXad2EtPdcl0-_ti9xCRkCHa5U"/><meta name="naver-site-verification" content="58945b2bbe2fe86252fa8c7b204b40f6019920e9"/><meta property="og:title" content="Been blog - javaScript"/><meta property="og:description" content="Been dev-note - javaScript"/><meta property="og:url" content="https://wonbeenna.github.io/blog/javaScript"/><meta property="og:site_name" content="Been blog"/><meta property="og:image" content="https://wonbeenna.github.io/favicon.png"/><meta property="og:image:width" content="800"/><meta property="og:image:height" content="600"/><meta property="og:image:alt" content="Been blog"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Been blog - javaScript"/><meta name="twitter:description" content="Been dev-note - javaScript"/><meta name="twitter:image" content="https://wonbeenna.github.io/favicon.png"/><meta name="twitter:image:width" content="800"/><meta name="twitter:image:height" content="600"/><meta name="twitter:image:alt" content="Been blog"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="192x192"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" noModule=""></script></head><body class="__className_471caf"><header class="sticky top-0 z-10 mx-auto my-0 h-[56px] border-b-[1px] border-b-gray200 bg-white px-[24px] py-0"><section class="m-auto flex h-full max-w-[970px] items-center justify-between"><div class="flex items-center gap-[20px]"><a href="/"><img alt="logo" loading="lazy" width="60" height="56" decoding="async" data-nimg="1" style="color:transparent" src="/assets/icons/been-logo.svg"/></a><div class="flex items-center gap-[20px]"><a href="/about">About</a></div></div><div class="flex items-center gap-[20px]"><a target="_blank" rel="noopener noreferrer" href="https://github.com/wonbeenna"><img alt="github" loading="lazy" width="30" height="30" decoding="async" data-nimg="1" style="color:transparent" src="/assets/icons/github.svg"/></a><a href="mailto:nwbnwb@naver.com"><img alt="email" loading="lazy" width="34" height="34" decoding="async" data-nimg="1" style="color:transparent" src="/assets/icons/mail.svg"/></a></div></section></header><main class="mx-auto my-0 max-w-[970px] p-[16px]"><section class="flex flex-col-reverse md:relative md:flex-row"><div class="flex flex-1 flex-col"><ol class="relative mx-0 my-[20px] flex w-full  flex-col gap-[40px] p-0"><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/jwt-decode"><img alt="jwt 토큰 decode 하기" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/javascript.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">jwt 토큰 decode 하기</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">jwt 토큰 decode 함수</p><span class="text-gray700">2023-08-31</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/audio"><img alt="Audio객체를 이용한 음악 재생" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/logo192.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">Audio객체를 이용한 음악 재생</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">Audio객체를 사용한 기업 과제 구현</p><span class="text-gray700">2023-05-27</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/debouce-throttle"><img alt="디바운싱과 쓰로틀링" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/javascript.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">디바운싱과 쓰로틀링</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">디바운싱과 쓰로틀링의 차이를 구분하고 hook으로 구현</p><span class="text-gray700">2023-05-13</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/graphql-1"><img alt="GraphQl 써보기(1)" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/graphql.svg"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">GraphQl 써보기(1)</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">GraphQl, Apollo Client를 사용</p><span class="text-gray700">2023-04-29</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/next-middleware"><img alt="Next.js middleware와 getServerSideProps" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/Nextjs.svg"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">Next.js middleware와 getServerSideProps</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">세션방식의 로그인 인증, middleware와 getServerSideProps를 사용해 구현한 기록</p><span class="text-gray700">2023-02-22</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/tailwindcss"><img alt="Nextjs에서 tailwind 써보기" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/tailwind-css-icon.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">Nextjs에서 tailwind 써보기</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">공식문서 보면서 tailwind 써보기</p><span class="text-gray700">2023-02-18</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/svelte-blog"><img alt="스벨트킷으로 블로그 만들어보기" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/svelte-icon.webp"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">스벨트킷으로 블로그 만들어보기</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">스벨트킷으로 블로그 만든 과정을 정리</p><span class="text-gray700">2023-01-30</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/react-testing-4"><img alt="리액트 테스팅(4)" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/test.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">리액트 테스팅(4)</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">jest와 react-testing-library</p><span class="text-gray700">2023-01-02</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/conditional-rendering"><img alt="리액트 조건부 렌더링에 대한 생각" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/logo192.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">리액트 조건부 렌더링에 대한 생각</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">해외 블로그를 보며 정리한 조건부 렌더링에 대한 생각</p><span class="text-gray700">2022-12-29</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/usecallback-and-usememo"><img alt="useCallback, useMemo 무조건 좋은가?" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/logo192.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">useCallback, useMemo 무조건 좋은가?</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">useCallback과 useMemo에 대한 생각 정리</p><span class="text-gray700">2022-12-28</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/react-testing-3"><img alt="리액트 테스팅(3)" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/test.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">리액트 테스팅(3)</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">jest와 react-testing-library</p><span class="text-gray700">2022-12-26</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/react-testing-2"><img alt="리액트 테스팅(2)" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/test.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">리액트 테스팅(2)</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">jest와 react-testing-library</p><span class="text-gray700">2022-12-14</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/react-testing-1"><img alt="리액트 테스팅(1)" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/test.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">리액트 테스팅(1)</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">jest와 react-testing-library</p><span class="text-gray700">2022-12-10</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/storybook"><img alt="Storybook 써보기" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/storybook.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">Storybook 써보기</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">스터디 하면서 처음 써본 Storybook</p><span class="text-gray700">2022-10-11</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/next-styled-component"><img alt="Next.js styled-component 적용 문제에 대해(_document.tsx)" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/Nextjs.svg"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">Next.js styled-component 적용 문제에 대해(_document.tsx)</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">next.js와 styled-component 사용시 발생한 에러</p><span class="text-gray700">2022-08-22</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/intersectionObserver"><img alt="IntersectionObserver로 데이터 요청해보기" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/logo192.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">IntersectionObserver로 데이터 요청해보기</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">IntersectionObserver를 활용해 스크롤 위치에서 데이터 불러오기</p><span class="text-gray700">2022-05-04</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/next-bundle-analyzer"><img alt="next/bundle-analyzer" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/logo192.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">next/bundle-analyzer</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">next/bundle-analyzer로 번들 크기 확인하기</p><span class="text-gray700">2022-02-22</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/ref-forwardRef"><img alt="리액트 ref 와 forwardRef (with. react-hook-form)" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/logo192.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">리액트 ref 와 forwardRef (with. react-hook-form)</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">react-hook-form 라이브러리와 ref의 동작</p><span class="text-gray700">2022-02-09</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/Speechsynthesis"><img alt="Speechsynthesis &amp; Google TTS" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/logo192.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">Speechsynthesis &amp; Google TTS</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">프로젝트 진행하며 경험해본 Speechsynthesis &amp; Google TTS</p><span class="text-gray700">2022-01-22</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/web-optimization-3"><img alt="웹성능 최적화(3)" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/logo192.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">웹성능 최적화(3)</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">웹성능 최적화3</p><span class="text-gray700">2022-01-04</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/web-optimization-2"><img alt="웹성능 최적화(2)" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/logo192.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">웹성능 최적화(2)</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">웹성능 최적화2</p><span class="text-gray700">2022-01-03</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/web-optimization"><img alt="웹성능 최적화(1)" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/logo192.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">웹성능 최적화(1)</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">웹성능 최적화1</p><span class="text-gray700">2022-01-01</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/svelte-react"><img alt="스벨트와 리액트" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/svelte-icon.webp"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">스벨트와 리액트</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">스벨트와 리액트에 대해 정리한 글</p><span class="text-gray700">2021-12-12</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/thinking-in-react-2"><img alt="React 처럼 생각하기(2)" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/logo192.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">React 처럼 생각하기(2)</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">리액트 문서 보며 정리</p><span class="text-gray700">2021-12-12</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/thinking-in-react"><img alt="React 처럼 생각하기" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/logo192.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">React 처럼 생각하기</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">리액트 문서 보며 정리</p><span class="text-gray700">2021-11-20</span></div></a></li><li class="mt-[30px] border-b-[1px] border-b-gray300 pb-[50px] md:mt-[50px] md:pb-[70px]"><a class="hover_card flex w-full flex-col items-center justify-between gap-0 md:flex-row md:gap-[40px]" href="/blog/javaScript/react-hook"><img alt="React Hook의 동작" loading="lazy" width="200" height="200" decoding="async" data-nimg="1" class="h-[200px] w-[200px] rounded-[14px]" style="color:transparent" src="/assets/postIcon/logo192.png"/><div class="flex min-h-[160px] w-full flex-col items-center justify-center md:min-h-[200px]"><h1 class="my-[12px] overflow-hidden text-ellipsis break-words text-[24px] font-bold text-black md:mt-0 md:text-[34px]">React Hook의 동작</h1><p class="mx-[14px] my-[12px] text-ellipsis break-keep text-[14px] text-gray900 md:text-[18px]">React Hook의 동작에 대해</p><span class="text-gray700">2021-11-07</span></div></a></li></ol></div><ul class="relative top-0 flex h-fit min-w-fit flex-row flex-wrap gap-[20px] py-[20px] pl-0 md:sticky md:top-[100px] md:flex-col md:flex-nowrap md:py-0 md:pl-[30px]"><h2 class="hidden text-[18px] font-bold md:inline">Category</h2><li><a class="font-[600] text-black" href="/blog/javaScript">javaScript (26)</a></li><li><a class="text-gray700" href="/blog/study">study (2)</a></li><li><a class="text-gray700" href="/blog/til">til (1)</a></li></ul></section></main><footer class="flex items-center justify-center pb-[16px] text-center text-[14px] text-gray600">Copyright © Been.</footer><script src="/_next/static/chunks/webpack-891dab1a18c2720c.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/0e4fe491bf84089c-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/media/627622453ef56b0d-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n3:HL[\"/_next/static/media/7d8c9b0ca4a64a5a-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n4:HL[\"/_next/static/media/8db47a8bf03b7d2f-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n5:HL[\"/_next/static/media/934c4b7cb736f2a3-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n6:HL[\"/"])</script><script>self.__next_f.push([1,"_next/static/css/48ff91835f2990e0.css\",\"style\"]\n0:\"$L7\"\n"])</script><script>self.__next_f.push([1,"8:I{\"id\":6054,\"chunks\":[\"272:static/chunks/webpack-891dab1a18c2720c.js\",\"971:static/chunks/fd9d1056-23f6e37ad1d1612c.js\",\"864:static/chunks/864-8d9b6481be2de97f.js\"],\"name\":\"\",\"async\":false}\na:I{\"id\":1729,\"chunks\":[\"272:static/chunks/webpack-891dab1a18c2720c.js\",\"971:static/chunks/fd9d1056-23f6e37ad1d1612c.js\",\"864:static/chunks/864-8d9b6481be2de97f.js\"],\"name\":\"\",\"async\":false}\nb:I{\"id\":4244,\"chunks\":[\"964:static/chunks/964-1c6e8b9c3261a3cb.js\",\"724:static/chunks/724-95707ae80dbaeeaf.js\",\"185:static/chunks"])</script><script>self.__next_f.push([1,"/app/layout-e94d10c3aeefd22c.js\"],\"name\":\"\",\"async\":false}\nc:I{\"id\":4724,\"chunks\":[\"964:static/chunks/964-1c6e8b9c3261a3cb.js\",\"724:static/chunks/724-95707ae80dbaeeaf.js\",\"254:static/chunks/app/blog/[category]/page-26335fa07fe6911a.js\"],\"name\":\"\",\"async\":false}\nd:I{\"id\":6964,\"chunks\":[\"964:static/chunks/964-1c6e8b9c3261a3cb.js\",\"724:static/chunks/724-95707ae80dbaeeaf.js\",\"185:static/chunks/app/layout-e94d10c3aeefd22c.js\"],\"name\":\"Image\",\"async\":false}\ne:I{\"id\":1443,\"chunks\":[\"272:static/chunks/webpack-891da"])</script><script>self.__next_f.push([1,"b1a18c2720c.js\",\"971:static/chunks/fd9d1056-23f6e37ad1d1612c.js\",\"864:static/chunks/864-8d9b6481be2de97f.js\"],\"name\":\"\",\"async\":false}\nf:I{\"id\":8639,\"chunks\":[\"272:static/chunks/webpack-891dab1a18c2720c.js\",\"971:static/chunks/fd9d1056-23f6e37ad1d1612c.js\",\"864:static/chunks/864-8d9b6481be2de97f.js\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"7:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/48ff91835f2990e0.css\",\"precedence\":\"next\"}]],[\"$\",\"$L8\",null,{\"buildId\":\"JmaPnO7GdC2BNFYMFC0zr\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/blog/javaScript\",\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"category\",\"javaScript\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"javaScript\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[false,\"$L9\"],\"globalErrorComponent\":\"$a\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[null,[\"$\",\"$Lb\",null,{\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-LFDRQZPCBN\"}],[\"$\",\"$Lb\",null,{\"id\":\"google-analytics\",\"children\":\"\\n          window.dataLayer = window.dataLayer || [];\\n          function gtag(){dataLayer.push(arguments);}\\n          gtag('js', new Date());\\n \\n          gtag('config', 'G-LFDRQZPCBN');\\n        \"}],[\"$\",\"body\",null,{\"suppressHydrationWarning\":true,\"className\":\"__className_471caf\",\"children\":[[\"$\",\"header\",null,{\"className\":\"sticky top-0 z-10 mx-auto my-0 h-[56px] border-b-[1px] border-b-gray200 bg-white px-[24px] py-0\",\"children\":[\"$\",\"section\",null,{\"className\":\"m-auto flex h-full max-w-[970px] items-center justify-between\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center gap-[20px]\",\"children\":[[\"$\",\"$Lc\",null,{\"href\":\"/\",\"children\":[\"$\",\"$Ld\",null,{\"src\":\"/assets/icons/been-logo.svg\",\"width\":60,\"height\":56,\"alt\":\"logo\"}]}],[\"$\",\"div\",null,{\"className\":\"flex items-center gap-[20px]\",\"children\":[\"$\",\"$Lc\",null,{\"href\":\"/about\",\"children\":\"About\"}]}]]}],[\"$\",\"div\",null,{\"className\":\"flex items-center gap-[20px]\",\"children\":[[\"$\",\"$Lc\",null,{\"href\":\"https://github.com/wonbeenna\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"children\":[\"$\",\"$Ld\",null,{\"src\":\"/assets/icons/github.svg\",\"width\":30,\"height\":30,\"alt\":\"github\"}]}],[\"$\",\"$Lc\",null,{\"href\":\"mailto:nwbnwb@naver.com\",\"children\":[\"$\",\"$Ld\",null,{\"src\":\"/assets/icons/mail.svg\",\"width\":34,\"height\":34,\"alt\":\"email\"}]}]]}]]}]}],[\"$\",\"main\",null,{\"className\":\"mx-auto my-0 max-w-[970px] p-[16px]\",\"children\":[\"$\",\"$Le\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lf\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"childProp\":{\"current\":[\"$\",\"$Le\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lf\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$Le\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",[\"category\",\"javaScript\",\"d\"],\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$Lf\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$L10\",\"$L11\",null],\"segment\":\"__PAGE__?{\\\"category\\\":\\\"javaScript\\\"}\"},\"styles\":[]}],\"segment\":[\"category\",\"javaScript\",\"d\"]},\"styles\":[]}],\"segment\":\"blog\"},\"styles\":[]}]}],[\"$\",\"footer\",null,{\"className\":\"flex items-center justify-center pb-[16px] text-center text-[14px] text-gray600\",\"children\":\"Copyright © Been.\"}]]}]]}],null]}]]\n"])</script><script>self.__next_f.push([1,"12:I{\"id\":7066,\"chunks\":[\"964:static/chunks/964-1c6e8b9c3261a3cb.js\",\"724:static/chunks/724-95707ae80dbaeeaf.js\",\"254:static/chunks/app/blog/[category]/page-26335fa07fe6911a.js\"],\"name\":\"\",\"async\":false}\n13:T6ae,"])</script><script>self.__next_f.push([1,"\nJSON 웹 토큰(JWT)\n\n일반적으로 **헤더.페이로드.서명** 으로 구성되어 있다.\n\n1.헤더 - 어떤 알고리즘으로 암호화 할것인지\n\n2.데이터 - 전달하려는 정보, 사용자의 id, name 등\n\n3\\. 서명 - 서버가 지정한 secret key로 암호화 시켜 토큰을 변조하기 어렵게 만듬\n\n이 세 부분을 Base64url로 인코딩해 \n\n```\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsb2dnZWRJbkFzIjoiYWRtaW4iLCJpYXQiOjE0MjI3Nzk2Mzh9.gzSraSYS8EXBxLN_oWnFSRgCzcmJmMjLiuyu5CSpyHI\n```\n\n위와 같은 형태로 파싱해 사용한다.\n\njwt 데이터 부분에서 정보를 가져와 사용할 수 있는데, decoding 해주어야 한다.\n\n```javascript\nexport const decodeJwtResponse = (token: string) =\u003e {\n  let base64Url = token.split('.')[1]\n  let base64 = base64Url?.replace(/-/g, '+')?.replace(/_/g, '/')\n  let jsonPayload = decodeURIComponent(\n    atob(base64)\n      .split('')\n      .map(function (c) {\n        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)\n      })\n      .join('')\n  )\n\n  return JSON.parse(jsonPayload)\n  let base64Payload = token.split('.')[1]\n\n  let payload = Buffer.from(base64Payload, 'base64')\n  return JSON.parse(payload.toString())\n}\n```\n\natob 함수는 node에서 더이상 지원하지 않아 아래로 수정\n\n```javascript\nexport const decodeJwtResponse = (token: string) =\u003e {\n  let base64Payload = token.split('.')[1]\n\n  let payload = Buffer.from(base64Payload, 'base64')\n\n  return JSON.parse(payload.toString())\n}\n```\n\ntoken을 split해 1번째 데이터에 해당하는 부분을 가져온 다음\n\nnode에서 지원하는 Buffer 객체를 사용해 바이너리로 변환\n\nbase64로 인코딩한 후 JSON으로 파싱한다\n"])</script><script>self.__next_f.push([1,"14:Tfb3,"])</script><script>self.__next_f.push([1,"\n얼마전 기업과제를 진행했다. Audio 객체를 이용한 음악 재생이었다.\n\nhttps://developer.mozilla.org/ko/docs/Web/API/Web_Audio_API/Using_Web_Audio_API\n\n## Audio 객체\n웹에서 음악을 재생하기 위해서는 new Audio 객체를 생성하거나, `\u003caudio\u003e` 태그를 사용해 Audio 객체를 가져올 수도 있다.\n\nAudio 객체는 음악을 재생하고, 일시정지하고, 음악의 길이를 구하는 등의 기능을 제공한다.\n\nAudio 객체는 다음과 같이 생성한다.\n\n```jsx\nlet audio = new Audio(url);\n```\n\n```jsx\n\u003caudio src={url} /\u003e;\n```\n\n과제를 제출하고 알게 되었는데, new Audio 객체를 사용하면 화면 밖에서도 audio를 다룰 수 있기때문에 `audio`태그를 사용할 필요가 없었다.\n\n둘중 하나만 사용해 Audio를 다룰 수 있는 객체를 가져오면 된다.\n\n```javascript\nlet audio = document.querySelector('audio');\naudio.play();\naudio.pause();\n```\n\n과제에서는 new Audio를 사용해 구현 하였다.\n```jsx\n  useEffect(() =\u003e {\n    setAudio(new Audio(url));\n}, [url, setAudio]);\n```\n먼저 server에서 받아온 Url을 state에 담아 주었고\n\n```jsx\n  useEffect(() =\u003e {\n    if (audio \u0026\u0026 isPlaying) {\n        audio?.play();\n    }\n}, [audio, isPlaying]);\n```\n\n리스트에서 음악을 선택하면 `isPlaying`이 true가 되고, `audio`가 생성되면 `audio.play()`를 실행한다.\n\n재생과 일시정지도 추가가 되어야 했다.\n\n```jsx\nconst handlePlayButton = () =\u003e {\n    if (audio?.paused) {\n        return audio.play();\n    }\n    return audio?.pause();\n}\n```\n음악이 정지중일땐 play, 음악이 재생중일땐 pause를 실행한다.\n\n---\n\n음악이 재샐중일때 progress bar도 구현이 필요했다.\n\n```jsx\nconst [rangeValue, setRange] = useState\u003cnumber\u003e(0);\nconst [currentTime, setCurrentTime] = useState\u003cstring\u003e('00:00');\nconst [duration, setDuration] = useState\u003cstring\u003e('00:00');\n\n\u003cprogress\n    className=\"progress\"\n    value={Math.floor(rangeValue)}\n    max=\"100\"\n    aria-valuemin={0}\n    aria-valuemax={100}\n    aria-valuenow={Math.floor(rangeValue)}\n    onClick={handleChangeProgressRange}\n/\u003e\n```\n\n`rangeValue`는 progress bar의 value값을 나타내고, `currentTime`는 현재 재생중인 시간을 나타낸다.\n\n`duration`는 음악의 전체 길이를 나타낸다.\n\n재생시간과 음악의 전체 길이가 `00:00`으로 표시되었어야했기 때문에 format함수를 만들었고, eventListener를 통해 재생시간과 음악의 전체 길이를 구했다.\n\n```js\nexport const getMusicTimeFormat = (time = 0) =\u003e {\n  let minutes = Math.floor((time % 3600) / 60)\n    .toString()\n    .padStart(2, '0');\n  let seconds = Math.floor(time % 60)\n    .toString()\n    .padStart(2, '0');\n\n  return minutes + ':' + seconds;\n};\n```\n```jsx\n  useEffect(() =\u003e {\n    audio?.addEventListener('timeupdate', () =\u003e {\n        setDuration(getMusicTimeFormat(audio.duration || 0));\n        setCurrentTime(getMusicTimeFormat(audio.currentTime));\n        setRange((audio?.currentTime / audio?.duration || 0) * 100);\n    });\n}, [audio]);\n````\n\n`timeupdate`이벤트는 음악이 재생중일때마다 발생한다.\n\n```js\n  const handleChangeProgressRange = (e: React.MouseEvent\u003cHTMLProgressElement\u003e) =\u003e {\n    if (audio) {\n        let clickPosition = e.pageX - e.currentTarget.offsetLeft;\n        let clickedValue = (clickPosition * e.currentTarget.max) / e.currentTarget.offsetWidth;\n        audio.currentTime = (parseInt(String(clickedValue), 10) / 100) * audio.duration;\n        setRange(parseInt(String(clickedValue), 10));\n    }\n};\n```\nprogressbar를 클릭했을 때는 해당 위치부터 audio를 재생해야했다.\n`clickPosition`은 progressbar를 클릭한 위치를 나타내고, `clickedValue`는 progressbar의 value값을 나타낸다.\n\n- e.pageX = 브라우저 상의 마우스 클릭 위치\n- e.currentTarget.offsetLeft = progressbar의 x축(왼쪽) 위치\n- e.currentTarget.max = progressbar의 최대값\n- e.currentTarget.offsetWidth = progressbar의 전체 너비\n\n\n"])</script><script>self.__next_f.push([1,"15:Te25,"])</script><script>self.__next_f.push([1,"\n### 디바운싱과 쓰로틀링\n\n\n- 디바운싱: 연속으로 호출되는 함수들 중 가장 마지막 함수(또는 제일 처음)만 호출하도록 하는 것\n- 쓰로틀링: 함수가 연속적으로 실행되는 경우 현재 실행되고 있는 함수가 없는 경우에만 함수를 실행함\n\n예를들어 검색을 요구하는 API에 \"test\"를 검색한다고 가정한 경우, 일반적인 경우에는 t, e, s, t 각 글자를 입력할 때 마다 API가 호출이 된다.\n\n이런 경우 불필요한 요청이 서버에 부담을 줄 수가 있다.\n\n이 때 디바운싱을 사용하게 된다면, 가장 마지막인 글자가 입력되고, 하나의 단어가 완성되었을때 API에 요청을 할 수 있다.\n\n쓰로틀링인 경우에는 t를 입력했을 때 API요청이 발생하고, 이후 일정 시간동안은 아무 응답도 받지 않는다.\n정해진 시간이 모두 지나고난 뒤에 마지막으로 입력된 글자까지 요청이 가게 된다.\n즉 실행 횟수에 제한을 거는 것이다.\n\n### 디바운싱\n```tsx\nimport { useEffect, useState } from 'react'\n\nfunction useDebounce\u003cT\u003e(value: T, delay?: number): T {\n  const [debouncedValue, setDebouncedValue] = useState\u003cT\u003e(value)\n\n  useEffect(() =\u003e {\n    const timer = setTimeout(() =\u003e setDebouncedValue(value), delay || 500)\n\n    return () =\u003e {\n      clearTimeout(timer)\n    }\n  }, [value, delay])\n\n  return debouncedValue\n}\n\nexport default useDebounce\n```\n```js\nimport { ChangeEvent, useEffect, useState } from 'react'\nimport { useDebounce } from 'usehooks-ts'\n\nexport default function Component() {\n  const [value, setValue] = useState\u003cstring\u003e('')\n  const debouncedValue = useDebounce\u003cstring\u003e(value, 500)\n\n  const handleChange = (event: ChangeEvent\u003cHTMLInputElement\u003e) =\u003e {\n    setValue(event.target.value)\n  }\n\n  // Fetch API (optional)\n  useEffect(() =\u003e {\n    // Do fetch here...\n    // Triggers when \"debouncedValue\" changes\n  }, [debouncedValue])\n\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003eValue real-time: {value}\u003c/p\u003e\n      \u003cp\u003eDebounced value: {debouncedValue}\u003c/p\u003e\n\n      \u003cinput type=\"text\" value={value} onChange={handleChange} /\u003e\n    \u003c/div\u003e\n  )\n}\n```\n출처: [react-hook](https://usehooks-ts.com/react-hook/use-debounce)\n\ninput feild에 값이 들어갈 때마다 onChange 이벤트가 트리거되고, hook으로 전달받은 value가 clearTimeout으로 초기화된 useEffect내부 setTimeout의 delay만큼 시간이 지난 후 debouncedValue로 return 된다.\n\n### 쓰로틀링\n```js\nimport { useEffect, useRef, useState } from 'react';\n\nconst useThrottle = (value, limit) =\u003e {\n    const [throttledValue, setThrottledValue] = useState(value);\n    const lastRan = useRef(Date.now());\n\n    useEffect(() =\u003e {\n        const handler = setTimeout(() =\u003e {\n            if (Date.now() - lastRan.current \u003e= limit) {\n                setThrottledValue(value);\n                lastRan.current = Date.now();\n            }\n        }, limit - (Date.now() - lastRan.current));\n\n        return () =\u003e {\n            clearTimeout(handler);\n        };\n    }, [value, limit]);\n\n    return throttledValue;\n};\n\nexport default useThrottle;\n```\n```js\nconst [value, setValue] = useState('');\n{...}\nconst throttleText = useThrottle(value, 1000);\n```\nhook이 실행되면 lastRan과 현재시간을 비교한다.\n\n만약 (Date.now() - lastRan.current) 즉, value가 입력된 시간이 limit보다 크다면 value를 throttledValue로 return하고, lastRan을 현재시간으로 초기화한다.\n\n만약 value가 입력된 시간이 limit보다 작다면 limit - value가 입력된 시간이 시간이 지난 후에 throttledValue로 return한다.\n\n\n\n\n"])</script><script>self.__next_f.push([1,"16:Tc4f,"])</script><script>self.__next_f.push([1,"\n## GraphQL 사용\n\nApollo client를 사용합니다.\n\nApollo Client는 GraphQL을 사용해 로컬 및 원격 데이터를 모두 관리할 수 있습니다. (상태 관리 라이브러리)\n\n---\n\n### React에 Apollo Client 연결\n```shell\nnpm install @apollo/client graphql\n```\n\nindex.ts 또는 App.ts 에서 작업을 진행합니다.\n```ts\nconst client = new ApolloClient({\n  uri: \"https://~/graphql\",\n  cache: new InMemoryCache(),\n});\n```\n\n다음과 같이 ApolloClient를 초기화 하고 `uri`와 `cache` 인스턴스를 전달합니다.\n\nuri에 서버주소를 작성합니다. endpoint를 따로 지정하지 않았다면 `/graphql`이 됩니다.\n\n사내에서는 `proxy`를 사용하기 때문에 `endpoint`를\n```ts\nconst client = new ApolloClient({\n  uri: '/api/graphql',\n  cache: new InMemoryCache()\n})\n```\n로 작성해주시면 됩니다.\n\n```ts\nfunction App() {\n  return (\n{...}\n        \u003cApolloProvider client={client}\u003e\n            \u003cDefaultRoutes /\u003e\n        \u003c/ApolloProvider\u003e\n{...}\n  )\n}\n```\nreact app에 전역으로 사용하기 위해서는 `ContextApi`를 사용하는 것 처럼 `ApolloProvider`로 앱을 감싸면 됩니다.\n\n---\n\n### 백엔드 데이터 읽기\n이제 `client`는 데이터를 가져올 준비가 되었습니다.\n\n\u003cimg src=\"/assets/blog/javaScript/graphql-2.png\" width=\"49%\" alt=\"post image\"/\u003e\n\u003cimg src=\"/assets/blog/javaScript/graphql-1.png\" width=\"49%\" alt=\"post image\"/\u003e\n\n`playground`에서 정의된 `schema`를 다운로드 받아 프로젝트 `root`에 위치시킵니다.\n\n```ts\n// const client = ...\n\nclient\n  .query({\n    query: gql`\n      query {\n        getAdminOrderProducts {\n          data {\n            id\n            status\n          }\n        }\n      }\n    `\n  })\n  .then((response) =\u003e console.log(response))\n  .catch((error) =\u003e console.log(error))\n```\n\n간단하게 불러올 수 있는 방법입니다. playground에 정의된 query를 요청하면\n타입과 함께 요청한 쿼리들이 response에 담깁니다.\n\n\u003cimg src=\"/assets/blog/javaScript/graphql-3.png\" width=\"49%\" alt=\"post image\"/\u003e\n\u003cimg src=\"/assets/blog/javaScript/graphql-4.png\" width=\"49%\" alt=\"post image\"/\u003e\n\n필드별로 분리하여 요청할 수 있습니다.\n```ts\nimport {gql, useQuery} from '@apollo/client'\n\nconst ORDER_QUERY = gql`\n  query {\n    getAdminOrderProducts {\n      data {\n        id\n        status\n      }\n    }\n  }\n`\n\n  const {loading, error, data} = useQuery(ORDER_QUERY)\n```\n\n`variables`로 `arguments`를 지정할 수 있습니다.\n\n`useQuery`에 옵션 `variables`은 GraphQL 쿼리에 전달하려는 모든 매개변수를 포함하는 객체입니다.\n\n아래와 같이 매개변수를 지정할 수 있습니다.\n```ts\nconst ORDER_QUERY = gql`\n  query getAdminOrderProducts($start: Int!, $perPage: Int!) {\n    getAdminOrderProducts(start: $start, perPage: $perPage) {\n      data {\n        id\n        status\n        product {\n          id\n        }\n        createdAt\n      }\n      total\n    }\n  }\n`\n\n  const {data, loading} = useQuery(ORDER_QUERY, {\n    variables: {\n      start: 0,\n      perPage: 20\n    }\n  })\n```\n\n지금까지는 백엔드의 데이터를 읽는 방법이었습니다.\n\n\n\n\n\n\n\n"])</script><script>self.__next_f.push([1,"17:T1a75,"])</script><script>self.__next_f.push([1,"\n인증방식에는 대표적으로 두가지가 있다.\n\n제일 많이 사용하는 세션 방식과 토큰 방식\n\n- 인증 -\u003e 유저가 누구인지 확인\n- 인가 -\u003e 유저의 요청에 대한 권한을 확인하고 허가\n\n---\n\n### 세션방식\n- 로그인 요청 -\u003e 서버에서 세션 key-value로 구분해 정보를 저장\n- 서버 -\u003e 클라이언트 측으로 http header cookie에 세션 id를 담아 전달\n- 클라이언트 쪽에서 response값으로 cookie에 저장된 세션을 확인할 수 있는데, 브라우저에 저장\n\n세션 방식은 HTTP요청이 노출되어도 세션 자체에는 의미있는 값이 없기 때문에 보안상 유리할 수 있다.\n\n각 사용자마다 고유한 id를 갖고 있기 때문에 매번 회원정보를 확인할 필요가 없다.\n\n서버에 따로 세션 저장소를 두기 때문에 사용자가 많아지면 서버에 부담이 간다.\n\n각 브라우저들은 보안상의 이슈로 서버와 프론트간의 도메인이 같아야 쿠키가 전달된다.\n\n- 프론트 측에서는 Axios 사용시 ```withCredentials: true```설정을 통해 서로 다른 도메인간의 요청에도 credential 정보를 받을 것인지 설정해야 한다.\n\n- 서버 측에서는 응답 헤더의 Access-Control-Allow-Credentials 항목을 true로 설정해야 하고,\n응답 헤더의 Access-Control-Allow-Origin의 값을 와일드 카드('*') 제외하고 설정 되어야 한다.\n\n---\n\n우선 localhost와 서버상의 도메인이 달라 proxy 설정을 해줬다.\n\n```ts\n// pages/api/[...path].ts\nimport type { NextApiRequest, NextApiResponse } from \"next\";\nimport httpProxyMiddleware from \"next-http-proxy-middleware\";\n\nexport const config = {\n  api: {\n    externalResolver: true\n  },\n}\n\nexport default (req: NextApiRequest, res: NextApiResponse) =\u003e {\n    httpProxyMiddleware(req, res, {\n        target: process.env.NEXT_PUBLIC_API_URL,\n        changeOrigin: true,\n        pathRewrite: [\n          {\n            patternStr: \"^/api/\",\n            replaceStr: \"/\",\n          },\n        ],\n        cookieDomainRewrite: {\n          \"*\": \"localhost\",\n        },\n      })\n    };\n```\n\n```ts\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  swcMinify: true,\n  reactStrictMode: true,\n  compiler: {\n    styledComponents: true,\n    removeConsole: process.env.NODE_ENV === \"production\",\n  },\n  async rewrites() {\n    return process.env.NODE_ENV === \"production\"\n      ? [\n          {\n            source: \"/api/:path*\",\n            destination: `${process.env.NEXT_PUBLIC_API_URL}/:path*`,\n          },\n        ]\n      : [];\n  },\n{...}\n};\n```\n---\n위 처럼 설정해 주니 서버에서 보낸 cookie가 localhost 브라우저에 잘 들어왔다.\n\n여기서 고민했던 부분이 csr환경이 아닌 next의 ssr환경인 프론트측 서버단에서는 유저인증을 어떻게 확인할 것인가 였다.\n\n우선 로그인 상태와 비로그인 상태에서 접근불가능한 페이지 접근시 리다이렉트를 시키는 방법으로 진행했다.\n\nNextjs middleware는 root폴더에 middleware.ts 파일을 만들어 주면 페이지 라우팅 되기 전에 middleware가 자동으로 실행된다.\n\nNextjs에서 지원하는 middleware는 들어오는 요청에 따라서 req, res, header를 다시 작성하거나 리디렉션 등을 수정하거나 재작성할 수 있다.\n```ts\nimport type { NextRequest } from \"next/server\";\nimport { fetchAuth, inValidateAuth, validateAuth } from \"@/lib/validateUser\";\n\nconst validatedUrl = [\n  \"/users/sign-in\",\n  \"/users/sign-up/normal\",\n  \"/users/sign-up/social\",\n  \"/users/sign-up/vendor\",\n  \"/users/password/reset\",\n];\n\nconst inValidateUrl = [\"/users/my-page\"];\n\nexport async function middleware(req: NextRequest) {\n  const url = req.nextUrl;\n\n  if (validatedUrl.includes(url.pathname)) {\n    return await validateAuth(req);\n  }\n\n  if (inValidateUrl.includes(url.pathname)) {\n    return await inValidateAuth(req);\n  }\n\n  return await fetchAuth(req);\n}\n\nexport const config = {\n  matcher: [\"/((?!api|_next/static|_next/image|favicon.ico|assets).*)\"],\n};\n```\n```ts\nimport { NextRequest, NextResponse } from \"next/server\";\n\nexport const validateUser = (req: NextRequest) =\u003e {\n  return fetch(\"url\", {\n    method: \"get\",\n    mode: \"cors\",\n    credentials: \"same-origin\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      cookie: `${req.headers.get(\"cookie\")}`,\n    },\n  });\n};\n\n{...}\n\nexport const fetchAuth = async (req: NextRequest) =\u003e {\n    try {\n        const res = NextResponse.next();\n\n        const response = await validateUser(req);\n        const data = await response.json();\n\n        if (response.ok) {\n            res.cookies.set(\"user\", JSON.stringify(data));\n            return res;\n        }\n\n        if (!response.ok) {\n            res.cookies.delete(\"user\");\n            res.cookies.delete(\"user.sid\");\n            return res;\n        }\n    } catch (e) {\n        throw new Error(\"Validate Error\");\n    }\n};\n```\n\n처음에 이런식으로 미들웨어를 구현했다. matcher로 페이지단만 확인했고, 페이지 라우팅시 유저 인증에 성공하면 cookie를 통해 유저정보와 세션을 전달했다.\n\n또 인증성공시 접근 x, 비인증시 접근 x 한 url을 확인해 리다이렉트 시키도록 했다.\n\n처음 해봤던 작업이었고, 제대로 구현한지 확신이 들지 않아 코드리뷰를 요청했다.\n\nmiddleware를 사용하지 않고 hocs를 사용해 auth를 호출하고, axios config에 headers를 전달하는 방법으로 알려주셨다.\n\n```ts\nimport React from \"react\";\nimport { GetServerSideProps, GetServerSidePropsContext } from \"next\";\nimport { getAuth } from \"@/models/auth\";\nimport merge from \"lodash/merge\";\n\nconst validatedUrl = [\n  \"/users/sign-in\",\n  \"/users/sign-up/normal\",\n  \"/users/sign-up/social\",\n  \"/users/sign-up/vendor\",\n  \"/users/password/reset\",\n];\n\nconst inValidateUrl = [\n  \"/users/my-page\",\n  \"/users/my-page/profile\",\n  \"/users/my-page/review\",\n];\n\nexport default function withAuth(getServerSideProps?: GetServerSideProps) {\n  return async function (context: GetServerSidePropsContext) {\n    const url = context.req.url as string;\n    let user = null;\n    try {\n      const res = await getAuth({ headers: context.req.headers });\n      user = res.data;\n    } catch (e) {}\n    if (inValidateUrl.includes(url) \u0026\u0026 !user) {\n      return {\n        redirect: {\n          permanent: false,\n          destination: \"/users/sign-in\",\n        },\n      };\n    }\n    {...}\n    const ret = await getServerSideProps?.(context);\n    return merge(ret, { props: { user } });\n  };\n}\n```\n\nmiddleware는 nextjs에서 서버도 같이 구성해 사용하면 좋을거라고 조언을 주셨다.\n\n```ts\n// page/*\n{...}\n\nexport const getServerSideProps = withAuth();\n\n{...}\n```\n"])</script><script>self.__next_f.push([1,"18:Tdf0,"])</script><script>self.__next_f.push([1,"\n예전에 하다가 중단된 프로젝트를 다시 시작해 보려고 새 레포로 마이그레이션 하는 과정에서\n\n패키지 버전도 올리고, 다른 기술을 찾아보다가 예전부터 써보고싶었던 tailwindcss를 써보기로 했다.\n\n```shell\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n테일윈드 설치 init을 하게 되면 `postcss.config.js` 파일과 `tailwind.config.js` 파일이 생성된다\n\n\n```js\n/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  content: [\n    \"./app/**/*.{js,ts,jsx,tsx}\",\n    \"./pages/**/*.{js,ts,jsx,tsx}\",\n    \"./components/**/*.{js,ts,jsx,tsx}\",\n\n    // Or if using `src` directory:\n    \"./src/**/*.{js,ts,jsx,tsx}\",\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n```\n나는 src 폴더를 사용하기 때문에 `\"./src/**/*.{js,ts,jsx,tsx}\"` 경로로 사용\n\n\n```css\n// globals.css\n@tailwind base; // 테일윈드의 기본 스타일\n@tailwind components; // 모든 클래스 요소\n@tailwind utilities; // 유틸리티\n```\n\n전역으로 설정\n\n---\n\n구글에서 지원하는 폰트를 사용해 tailwind에 적용\n\n```js\n// Layout\nconst roboto = Roboto({\n    subsets: [\"latin\"],\n    weight: [\"400\", \"500\", \"700\"],\n    variable: \"--font-roboto\"\n});\n\nconst Layout = ({ children }: { children: React.ReactNode }) =\u003e {\n    return (\n        \u003cmain className={`max-w-3xl m-auto p-3 text-black-500 ${roboto.className} font-sans`}\u003e\n            \u003cHeader /\u003e\n            {children}\n        \u003c/main\u003e\n    );\n};\n\nexport default Layout;\n```\n\n```js\n// tailwind.config.js\n/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n    content: [\"./src/**/*.{js,ts,jsx,tsx}\"],\n    theme: {\n        extend: {\n            colors: {\n                primary: {\n                    50: \"#f4f6fa\",\n                    100: \"#e8edf5\",\n                    200: \"#c6d1e5\",\n                    300: \"#a4b6d5\",\n                    400: \"#5f7fb6\",\n                    500: \"#1b4897\",\n                    600: \"#184188\",\n                    700: \"#143671\",\n                    800: \"#102b5b\",\n                    900: \"#0d234a\"\n                },\n                secondary: {\n                    50: \"#fefaf5\",\n                    100: \"#fcf5eb\",\n                    200: \"#f9e6cd\",\n                    300: \"#f5d7af\",\n                    400: \"#edb872\",\n                    500: \"#e59a36\",\n                    600: \"#ce8b31\",\n                    700: \"#ac7429\",\n                    800: \"#895c20\",\n                    900: \"#704b1a\"\n                },\n                black: {\n                    50: \"#f5f5f5\",\n                    100: \"#eaebeb\",\n                    200: \"#cbcccd\",\n                    300: \"#acaeaf\",\n                    400: \"#6d7174\",\n                    500: \"#2f3438\",\n                    600: \"#2a2f32\",\n                    700: \"#23272a\",\n                    800: \"#1c1f22\",\n                    900: \"#17191b\"\n                },\n                white: \"#ffffff\"\n            },\n            fontFamily: {\n                sans: [\"var(--font-roboto)\"]\n            }\n        }\n    }\n};\n\n```\n\n테일윈드 자체에 기본 색상이 지정된 것도 있었고,\n\n이런식으로 색상도 지정하면 자동으로 적용되는것 같다.\n\n기본색상을 완전히 바꾸려면 `theme.colors`서 설정이 가능하다고 한다.\n\n---\n\n- 조건부는 템플릿 리터럴을 사용\n\n- 반응형\n```js\n\u003cimg class=\"w-16 md:w-32 lg:w-48\" src=\"...\"\u003e\n```\n\n- hover나 focus 등\n```js\n\u003cbutton class=\"dark:md:hover:bg-fuchsia-600 ...\"\u003e\n  Save changes\n\u003c/button\u003e\n```\n"])</script><script>self.__next_f.push([1,"19:T1aed,"])</script><script>self.__next_f.push([1,"\n```shell\nnpm create svelte@latest my-app\ncd my-app\nnpm install\nnpm run dev\n```\n\nSSG 정적 페이지를 구성하는 어댑터\n```shell\nnpm i -D @sveltejs/adapter-static\n```\n---\nsvelte.config.js\n```js\nimport adapter from '@sveltejs/adapter-static';\n\nexport default {\n  kit: {\n    adapter: adapter()\n  }\n};\n```\n---\nsrc/routes/+layout.js\n```js\n// This can be false if you're using a fallback (i.e. SPA mode)\nexport const prerender = true;\n```\n---\n\n### 레이아웃 구성\n\n```js\n\u003cscript\u003e\n\timport Header from '$lib/components/Layout/Header.svelte';\n\timport Footer from '$lib/components/Layout/Footer.svelte';\n\n\texport let data;\n\u003c/script\u003e\n\n\u003cHeader /\u003e\n    \u003cmain\u003e\n\t\t\u003cslot /\u003e\n    \u003c/main\u003e\n\u003cFooter /\u003e\n```\nslot에 스벨트 페이지들이 렌더되게 된다.\n\n스벨트킷은 넥스트와 비슷하게 routes에서 라우팅이 된다.\n\n---\n\n### 데이터 가져오기\n\nsrc/routes/+page.svelte\n```js\n\u003cscript\u003e\n\timport Pagination from '$lib/components/Posts/Pagination.svelte';\n\timport '$lib/styles/_main.scss';\n\timport PostList from '$lib/components/Posts/PostList.svelte';\n\timport Category from '$lib/components/Posts/Category.svelte';\n\timport { MetaTags } from 'svelte-meta-tags';\n\timport { seoMeta, seoOg } from '$lib/config';\n\texport let data;\n\u003c/script\u003e\n\n\u003cMetaTags {...seoMeta} openGraph={{ ...seoOg }} /\u003e\n\n\u003ch1\u003eBlog\u003c/h1\u003e\n\n\u003cCategory categories={data.categories} /\u003e\n\n\u003cPostList posts={data} /\u003e\n\n\u003cPagination currentPage={1} totalPosts={data.total} /\u003e\n\n```\n+page.js는 페이지와 연결된 로드 함수이며, 데이터를 로드한 다음 페이지가 로드된 데이터를 넘겨 받아 렌더링한다.\nSSR, CSR 모두 렌더링 할 수 있다.\n\n+page.server.js 는 항상 서버측에서 로드가 실행된다.\n\n또 src/routes/api 는 독립적인 API 경로이며 페이지와 연결되지 않는다.\n\nsrc/routes/+page.server.js\n```js\nimport { postsPerPage } from '$lib/config';\nimport fetchPosts from '$lib/utils/fetchPosts';\n\nexport const load = async ({ fetch }) =\u003e {\n\tconst options = {\n\t\tlimit: postsPerPage\n\t};\n\tconst { posts } = await fetchPosts(options);\n\n\treturn { posts, total, categories };\n};\n\n```\n\nsrc/routes/api 에서 만든 fetchPosts 함수를 사용해\n\n페이지 진입시 5개의 포스트를 먼저 가져왔다.\n\n---\n\nsrc/lib/_posts에 각 게시글인 마크다운 파일들을 만들었다.\n```js\nimport { postsPerPage } from '$lib/config';\n\nconst fetchPosts = async () =\u003e {\n\tconst posts = await Promise.all(\n\t\tObject.entries(import.meta.glob('/src/lib/_posts/**/*.md')).map(async ([path, resolver]) =\u003e {\n\t\t\tconst { metadata } = await resolver();\n\t\t\tconst slug = path.split('/').pop()?.slice(0, -3);\n\t\t\treturn { ...metadata, slug };\n\t\t})\n\t);\n\n\tsortedPosts = sortedPosts.map((post) =\u003e ({\n\t\tslug: post.slug,\n\t\ttitle: post.title,\n\t\tdescription: post.description,\n\t\tcategory: post.category,\n\t\ttitleImage: post.titleImage,\n\t\tdate: new Intl.DateTimeFormat('ko-KR').format(new Date(post.date))\n\t}));\n\n\treturn {\n\t\tposts: sortedPosts\n\t};\n};\n\nexport default fetchPosts;\n```\n\n마크다운 파일들을 가져오는 함수\n\n```markdown\n---\ntitle: 스벨트킷으로 블로그 만들기\ndate: 2023-01-30\ndescription: 스벨트킷으로 블로그 만든 과정을 정리\ncategory: javaScript\ntitleImage: /postIcon/svelte-icon.webp\n---\n```\n\n\n위에 작성된 title, date, description... 들이 metadata가 된다.\n\n---\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport const load = async ({ params }) =\u003e {\n\ttry {\n\t\tconst post = await import(`../../../../lib/_posts/${params.category}/${params.post}.md`);\n\n\t\treturn {\n\t\t\tPostContent: post.default.render().html,\n\t\t\tmeta: {\n\t\t\t\t...post.metadata,\n\t\t\t\tdate: new Intl.DateTimeFormat('ko-KR').format(new Date(post.metadata.date)),\n\t\t\t\tslug: params.post\n\t\t\t}\n\t\t};\n\t} catch (err) {\n\t\tthrow error(404, err);\n\t}\n};\n\n```\nsrc/routes/blog/[category]/[post] 진입시 load 함수의 context.params를 통해 해당 게시글을 가져온다.\n\n---\n\n### sitemap, rss 만들기\n\nsrc/sitemap.xml/+server.ts\n\n```js\nimport fetchPosts from '$lib/utils/fetchPosts';\n\nexport const prerender = true;\n\nexport const GET = async () =\u003e {\n\tconst { posts } = await fetchPosts({ limit: -1 });\n\tconst links = posts.map(\n\t\t(p) =\u003e `\n    \u003curl\u003e\n      \u003cloc\u003ehttps://wonbeenna.github.io/blog/${p.category}/${p.slug}\u003c/loc\u003e\n      \u003clastmod\u003e${new Date(p.date).toISOString()}\u003c/lastmod\u003e\n      \u003cpriority\u003e1.0\u003c/priority\u003e\n    \u003c/url\u003e\n  `\n\t);\n\tconst xml = `\n    \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\n    \u003curlset\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd\"\n      xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n      xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\"\n      xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\"\n      xmlns:news=\"http://www.google.com/schemas/sitemap-news/0.9\"\n      xmlns:mobile=\"http://www.google.com/schemas/sitemap-mobile/1.0\"\n      xmlns:pagemap=\"http://www.google.com/schemas/sitemap-pagemap/1.0\"\n      xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"\n    \u003e\n        \u003curl\u003e\n            \u003cloc\u003ehttps://wonbeenna.github.io/\u003c/loc\u003e\n            \u003cpriority\u003e1.0\u003c/priority\u003e\n        \u003c/url\u003e\n\n        \u003curl\u003e\n            \u003cloc\u003ehttps://wonbeenna.github.io/about\u003c/loc\u003e\n            \u003cpriority\u003e1.0\u003c/priority\u003e\n        \u003c/url\u003e\n\n    ${links.join('')}\n    \u003c/urlset\u003e\n  `.trim();\n\treturn new Response(xml, { headers: { 'Content-Type': 'text/xml; charset=utf-8' } });\n};\n```\n\nGET 메소드를 사용해 서버에서 빌드시 sitemap.xml을 생성\n\nrss도 위와 동일하다.\n\n---\n\n### 마치며\n\n최근에 스벨트를 공부해보는 기회가있어, 스벨트킷을 사용해 간단한 블로그를 만들어 봤다.\n\n아직 깊게 사용해보진 못했지만, 먼저 리액트와 비교했을 때 코드량이 많이 줄어든 느낌이다.\n\n- 프레임워크는 코드량이 적을 수록 속도가 빠르다고 들었다.\n\n- 순수한 native가 가장 좋다.\n\n- 아무리 좋은 프레임워크라도 vanilla js를 따라갈 수는 없다.\n\n그런 면에서 virtual DOM을 사용하지 않는 스벨트가 가장 빠를 것이다. 하지만 최적화는 개발자의 몫..\n\n- 스벨트는 런타임이 아닌 컴파일러에 가깝기 때문에 실제 실행 가능한 vanilla js를 만들어 준다.\n\n리액트였으면 useState니 뭐니~ 상태 관리니~ 했을 것 같은데 스벨트는 변수 하나만 선언하면 가능했다.\n\n- 리액트에 hook, jsx, context, use함수 등 규칙들이 필요없었고, 오로지 html, css, js로 개발할 수 있다.\n\n요즘 많이 핫하고 뜨는 프레임워크라고 해서 정보들이 많을줄 알았는데 생각보다 더 정보가 없었다.\n\n구글링을 해도 스벨트 관련된 정보들이 많진 않았다. 거의 공식블로그를 많이 참고했다.\n\n그래도 앞으론 리액트를 더 공부 할 것이다. 먹고 살려면 ㅎㅎ\n\n"])</script><script>self.__next_f.push([1,"1a:T9de,"])</script><script>self.__next_f.push([1,"\n\n얼마전 해외 블로그를 구경하다가 이런 글을 보았다.\n\n-   리액트 조건부 렌더링에서 생각없이 \u0026\u0026 연산자를 사용하지 말아라\n-   무조건 \u0026\u0026 연산자를 사용하면 버그가 발생할 수 있다?\n\n이 글을 보면서 올바르게 사용하는 방법과,\n\n어떤식으로 사용하면 버그가 발생할 수 있는지 생각해 보는 계기가 되었다.\n\n우선 \u0026\u0026 연산자는 논리 연산자로 예를 들면 다음과 같이 동작한다\n\n```javascript\nconst a = 3;\nconst b = -2;\n\nconsole.log(a \u0026\u0026 b);\n// expected output: -2\n```\n\n왼쪽에서 오른쪽으로 값을 평가하고 true인 경우 오른쪽으로 false인 경우 평가대상이된 피연산자를 반환한다.\n\n```javascript\nfunction Component({ condition }) {\n\n  return (\n    \u003cdiv\u003e\n      {condition \u0026\u0026 \u003cOtherComponent /\u003e}\n     \u003c/div\u003e\n  );\n}\n```\n\nOr\n\n```javascript\nfunction Component({ condition }) {\n\n  return (\n    \u003cdiv\u003e\n      {condition ? \u003cOtherComponent /\u003e : null}\n     \u003c/div\u003e\n  );\n}\n```\n\n[리액트 공식문서](https://reactjs.org/docs/conditional-rendering.html)에는 \u0026\u0026 연산자를 쓰는데 유용할 수 있다고 설명하고 있으며,\n\n보통 삼항 연산자는 코드의 가독성 때문에 잘 사용하지 않고, 또 세개의 항이 없는 경우에도 사용하지 않는다.\n\n위 같은 경우 문제될 수 있는 상황이 있는데, \n\n```javascript\nfunction Component() {\n  const count = 0;\n\n  return (\n    \u003cdiv\u003e\n      {count \u0026\u0026 \u003ch1\u003e{count}\u003c/h1\u003e}\n     \u003c/div\u003e\n  );\n}\n```\n\njs의 falsy값을 평가 할때이다.\n\n[https://developer.mozilla.org/ko/docs/Glossary/Falsy](https://developer.mozilla.org/ko/docs/Glossary/Falsy)\n\ncount = 0 은 **false**로 평가되고, \u0026\u0026 연산자를 사용하기 때문에 0을 반환하게 되므로 내가 생각한 의도대로 동작하지 않을것이다.\n\n```javascript\n\u003cdiv\u003e0\u003c/div\u003e\n```\n\n이런 경우 count 를 Boolean으로 평가하게 하면 의도한대로 동작하게 된다. \n\n```javascript\nfunction Component() {\n  const count = 0;\n\n  return (\n    \u003cdiv\u003e\n      {!!count \u0026\u0026 \u003ch1\u003e{count}\u003c/h1\u003e}\n     \u003c/div\u003e\n  );\n}\n```\n\n따라서, 무조건 \u0026\u0026 연산자를 피하는것 보다는 평가 대상이 되는 값을 생각해보며 사용하는게 좋을 것 같다.\n\n실제 개발하면서\n\nNothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.\n\n이런 에러를 만난 적이 많았는데, 위와 관련된 것이 아닌가 생각 된다.\n\n조금 더 생각하면서 개발하자\n"])</script><script>self.__next_f.push([1,"1b:Tff5,"])</script><script>self.__next_f.push([1,"\n예전부터 궁금했었던 부분이었다.\n\n**useCallback**과 **useMemo** hook은 함수와 값을 메모이제이션 해주는 역할을 한다.\n\n그렇다면 **무조건 쓰기만하면** 성능상 이점을 가져갈 수 있을까?\n\n리액트는 아래 세가지인 경우 렌더링을 발생시킨다.\n\n**\\- state 변경이 있을 때**\n\n**\\- props 변경이 있을 때**\n\n**\\- 부모 컴포넌트가 업데이트 될 때 모든 자식 컴포넌트**\n\n이때 불필요한 렌더링을 막기위해 useCallback과 useMemo를 사용하지만, 최적화에는 항상 비용이 따른다.\n\n---\n\n```javascript\nimport {useState} from \"react\";\nimport Count from \"./Count\";\n\nfunction App() {\n    const [count, setCount] = useState(1);\n\n    const handleClick = () =\u003e {\n        setCount(prevCount =\u003e prevCount + 1)\n    }\n\n    return (\n        \u003cdiv\u003e\n            \u003ch1\u003e{count}\u003c/h1\u003e\n            \u003cdiv\u003e\n                \u003cCount onClick={handleClick} /\u003e\n            \u003c/div\u003e\n        \u003c/div\u003e\n    );\n}\n\nexport default App;\n```\n\n위와 같은 코드에서 App에 state가 변경되기 때문에 Count도 렌더링 될것이다.\n\n\u003cimg src=\"/assets/blog/javaScript/use.gif\" width=\"100%\" alt=\"post image\"/\u003e\n\n부모컴포넌트의 state가 변경되었고,\n\nhandleClick() 함수의 참조 동일성이 일치하지 않아 리렌더링 되고있다.\n\n```javascript\nimport React from 'react';\n\nfunction Count(props) {\n    console.log('CountRender')\n    return (\n        \u003cdiv\u003e\n            \u003cbutton onClick={props.onClick}\u003eClick\u003c/button\u003e\n        \u003c/div\u003e\n    );\n}\n\nexport default React.memo(Count);\n```\n\n자식 컴포넌트에 React.memo로 감싸주면 props를 비교할 것이다.\n\n이때 props onClick은 App에서 메모이제이션이 되지않아 여전히 리렌더링이 발생한다.\n\n```javascript\nconst handleClick = useCallback(() =\u003e {\n    setCount(prevCount =\u003e prevCount + 1)\n}, [])\n```\n\nuseCallback으로 감싸주면 handleClick은 메모이제이션되어 새로 생성되지않고, props로 전달되기 때문에 리렌더링이 발생하지 않는다.\n\n\u003cimg src=\"/assets/blog/javaScript/use(1).gif\" width=\"100%\" alt=\"post image\"/\u003e\n\n---\n\n리액트에서 이야기하는 useMemo는 매렌더링마다 고비용 연산을 피하기 위해 사용한다고 하지만, 고비용에 대한 이야기에 대해서는 자세하게 나와있지 않다.\n\n리액트에서 이야기하는 고비용 연산은 하위 렌더트리들을 렌더링하는 연산을 이야기 하는 것이고, 이러한 경우가 아니라면 거의 대부분 useMemo를 사용하지 않아도 된다.\n\n---\n\n```javascript\nconst Component = () =\u003e {\n\n  const fetch = useCallback(() =\u003e {\n    console.log('fetch');\n  }, []);\n\n  useEffect(() =\u003e {\n    fetch();\n  }, [fetch]);\n\n  {...}\n};\n```\n\nuseMemo와 useCallback은 초기 렌더링에는 쓸모가 없다. 오히려 초기 렌더링에 useMemo와 useCallback이 값을 저장하는 행위는 오히려 성능을 저하시킬 수 있다는 것을 생각하자.\n\n위와같은 코드에서 fetch가 변경되어야 useCallback을 사용하는 것이 의미가 있다.\n\n---\n\n앱이 점점 커지고 모든 값이나 함수에 useMemo와 useCallback을 사용한다면 오히려 앱이 느려지는 원인이 될 수 있다.\n\n[https://ko.reactjs.org/docs/optimizing-performance.html#avoid-reconciliation](https://ko.reactjs.org/docs/optimizing-performance.html#avoid-reconciliation)\n\n단순한 값이나 함수를 메모이제이션 하는것 보다는 앱 설계 단계부터 리렌더링이 발생할 수 있는 부분을 생각하고, 리렌더링이 발생하는 특정 부분에서만 메모이제이션을 사용하는게 앱을 최적화 하는데 더 좋을 것이다.\n\n단순한 값이나 함수를 메모이제이션 하는건 오히려 더 느려질 뿐만 아니라, 성능에 미미하게 영향을 끼칠것이다.\n\n참고:\n\n[https://beta.reactjs.org/reference/react/useMemo#usage](https://beta.reactjs.org/reference/react/useMemo#usage)\n\n[https://www.developerway.com/posts/how-to-use-memo-use-callback](https://www.developerway.com/posts/how-to-use-memo-use-callback)\n"])</script><script>self.__next_f.push([1,"1c:T84a,"])</script><script>self.__next_f.push([1,"\n### fireEvent를 userEvent로 바꿔보기\n\n```shell\nnpm i @testing-library/user-event\n```\n\n```js\ntest('Checkbox enables button on first click and disableds on second click', async () =\u003e {\n  const user = userEvent.setup();\n\n  render(\u003cSummaryForm /\u003e);\n\n  const checkbox = screen.getByRole('checkbox', {\n    name: /terms and conditions/i\n  });\n  const confirmButton = screen.getByRole('button', {\n    name: /confirm order/i\n  });\n\n  await user.click(checkbox);\n  expect(confirmButton).toBeEnabled();\n\n  await user.click(checkbox);\n  expect(confirmButton).toBeDisabled();\n});\n```\n\nasync/await 으로 비동기 처리해주지 않으면, expect가 먼저 실행되기 때문에 오류가 발생한다\n\n---\n\n### Screen 메소드들 써보기\n\n```js\ntest('popover responds to hover', async () =\u003e {\n  const user = userEvent.setup();\n\n  render(\u003cSummaryForm /\u003e);\n\n  // popover starts out hidden\n  const nullPopover = screen.queryByText(/no ice cream will actually be delivered/i);\n  expect(nullPopover).not.toBeInTheDocument();\n\n  // popover appears on mouseover of checkbox label\n  const termsAndConditions = screen.getByText(/terms and conditions/i);\n  await user.hover(termsAndConditions);\n  const popover = screen.getByText(/no ice cream will actually be delivered/i);\n  expect(popover).toBeInTheDocument();\n\n  // popover disappears when we mouse out\n  await user.unhover(termsAndConditions);\n  expect(popover).not.toBeInTheDocument();\n});\n```\n\n- get : 요소 조회시 나타날 것으로 예상되는 경우 -\u003e 일치하는 요소가 없으면 Error를 반환\n\n- query : 요소가 존재하는지 확인하는 경우 -\u003e 일치하는 요소가 없으면 null을 반환\n\n- find : 요소가 비동기적으로 표시될 수 있는 경우인지\n\n```js\nconst popover = (\n  \u003cPopover id=\"popover-basic\"\u003e\n    \u003cPopover.Body\u003eNo ice cream will actually be delivered\u003c/Popover.Body\u003e\n  \u003c/Popover\u003e\n);\n\nconst checkboxLabel = (\n  \u003cspan\u003e\n    I agree to\n    \u003cOverlayTrigger trigger={['hover', 'focus']} placement=\"right\" overlay={popover}\u003e\n      \u003cspan style={{color: 'blue'}}\u003eTerms and Conditions\u003c/span\u003e\n    \u003c/OverlayTrigger\u003e\n  \u003c/span\u003e\n);\n```\n"])</script><script>self.__next_f.push([1,"1d:Tff3,"])</script><script>self.__next_f.push([1,"\n### * Mock Service Worker\n\n백엔드에서 데이터를 가져오는 부분을 테스트\n\n- MSW 작동 방식\n\n브라우저에 서비스 워커를 등록해 외부로 나가는 네트워크 리퀘스트를 감지\n\n요청을 실제 서버로 갈 때 중간에 가로채 MSW 클라이언트 사이드 라이브러리로 보내고, 등록된 핸들러에서 요청을 처리한 후 모의 응답을 보낸다.\n\n---\n\n### * jest를 사용한 node와 통합하기\n\n```shell\nnpm install msw --save\n```\n\n- 핸들러 생성하기\n\n```js\nimport {rest} from 'msw';\n\nexport const handlers = [\n  rest.get('http://localhost:5000/products', (req, res, ctx) =\u003e {\n    return res(\n      ctx.json([\n        {\n          name: 'America',\n          imagePath: '/images/america.jpeg'\n        },\n        {\n          name: 'England',\n          imagePath: '/images/england.jpeg'\n        }\n      ])\n    );\n  }),\n  rest.get('http://localhost:5000/options', (req, res, ctx) =\u003e {\n    return res(\n      ctx.json([\n        {\n          name: 'Insurance'\n        },\n        {\n          name: 'Dinner'\n        }\n      ])\n    );\n  })\n];\n```\n\n- mocking 서버 생성하기\n\n```js\nimport {setupServer} from 'msw/node';\nimport {handlers} from './handlers';\n\nexport const server = setupServer(...handlers);\n```\n\n- setupTest.js에 서버 생성\n\n```js\n// jest-dom adds custom jest matchers for asserting on DOM nodes.\n// allows you to do things like:\n// expect(element).toHaveTextContent(/react/i)\n// learn more: https://github.com/testing-library/jest-dom\nimport '@testing-library/jest-dom';\n\nimport {server} from './mocks/server';\n\nbeforeAll(() =\u003e server.listen()); // 테스트 시작 전에 서버 listen\nafterEach(() =\u003e server.resetHandlers()); // 테스트 중 다른 테스트에 영향이 가지 않도록\nafterAll(() =\u003e server.close()); // 테스트 후 서버를 클린업\n```\n\n- 테스트 코드 작성\n\n```js\nimport {server} from '../../../mocks/server';\nimport Type from '../Type';\nimport {rest} from 'msw';\nimport {render, screen} from '@testing-library/react';\n\ntest('displays product images from server', async () =\u003e {\n  render(\u003cType orderType=\"products\" /\u003e);\n\n  // 서버에서 받아온 이미지\n  const productImages = await screen.findAllByRole('img', {\n    name: /product$/i\n  });\n  expect(productImages).toHaveLength(2);\n\n  const altText = productImages.map((element) =\u003e element.alt);\n  expect(altText).toEqual(['America product', 'England product']);\n});\n\ntest('fetch option information from server', async () =\u003e {\n  render(\u003cType orderType=\"options\" /\u003e);\n\n  const optionCheckboxes = await screen.findAllByRole('checkbox');\n\n  expect(optionCheckboxes).toHaveLength(2);\n});\n\ntest('when fetching product datas, face an error', async () =\u003e {\n  // 서버에 대한 에러 확인\n  server.resetHandlers(\n    rest.get('http://localhost:5000/products', (req, res, ctx) =\u003e {\n      return res(ctx.status(500));\n    })\n  );\n\n  render(\u003cType orderType=\"products\" /\u003e);\n\n  const errorBanner = await screen.findByTestId('error-banner');\n  expect(errorBanner).toHaveTextContent('에러가 발생했습니다.');\n});\n```\n\n- 컴포넌트\n\n```js\nimport React, {useEffect, useState} from 'react';\nimport axios from 'axios';\nimport Products from './Products';\nimport ErrorBanner from '../../components/ErrorBanner';\nimport Options from './Options';\n\nconst Type = ({orderType}) =\u003e {\n  const [items, setItems] = useState([]);\n  const [error, setError] = useState(false);\n\n  useEffect(() =\u003e {\n    loadItems(orderType);\n  }, [orderType]);\n\n  const loadItems = async (orderType) =\u003e {\n    try {\n      const response = await axios.get(`http://localhost:5000/${orderType}`);\n      setItems(response.data);\n    } catch (error) {\n      setError(true);\n    }\n  };\n\n  const ItemComponents = orderType === 'products' ? Products : Options;\n\n  const optionItems = items.map((item) =\u003e {\n    return \u003cItemComponents key={item.name} name={item.name} imagePath={item.imagePath} /\u003e;\n  });\n\n  if (error) {\n    return \u003cErrorBanner message=\"에러가 발생했습니다.\" /\u003e;\n  }\n\n  return \u003cdiv\u003e{optionItems}\u003c/div\u003e;\n};\n\nexport default Type;\n```\n"])</script><script>self.__next_f.push([1,"1e:T1633,"])</script><script>self.__next_f.push([1,"\n### * Jest - Facebook에서 만든 테스팅 프레임 워크.\n\n주로 단위 (unit) 테스트를 위해 사용.\n\n- filename.test.js\n\n- filename.spec.js\n\nAll files inside \"tests\" folders\n\n- describe -\u003e 테스트를 그룹화 하는데 사용\n\n- test(it) - 개별 테스트를 수행\n\n- test(it) - 개별 테스트를 수행\n\n- test(it) - 개별 테스트를 수행\n\n- expect 함수는 값을 테스트할 때마다 사용, matcher(다른 방법으로 값을 테스트)와 함께 사용\n\n---\n\n### 시작해보기\n\ncra 폴더로 가서\n\n```shell\nnpm test\n```\n\n파일명에 test가 들어간 파일을 찾는다.\n\na로 App.test.js에 있는 모든 테스트를 실행\n\n```js\ntest('renders learn react link', () =\u003e {\n  render(\u003cApp /\u003e);\n  const linkElement = screen.getByText(/learn react/i);\n  expect(linkElement).toBeInTheDocument();\n});\n```\n\n- render함수는 DOM에 컴포넌트를 랜더링 하는 함수, return은 RTL(리액트 테스트 라이브러리)에 쿼리 함수와 기타 유틸리티를 담고 있는 객체를 리턴한다.\n\n```js\ntest('renders learn react link', () =\u003e {\n  const { getByText } = render(\u003cApp /\u003e);\n  const linkElement = getByText(/learn react/i);\n  expect(linkElement).toBeInTheDocument();\n});\n```\n\n아래 처럼도 쓸수 있다. (쿼리함수를 직접 쓰는 경우는 거의 없고 screen 객체로 이용)\n\n```js\n\u003ca\n  className=\"App-link\"\n  href=\"https://reactjs.org\"\n  target=\"_blank\"\n  rel=\"noopener noreferrer\"\n\u003e\n  Learn React\n\u003c/a\u003e\n```\n\nlinkElement가 Document안에 있는지 판단하는 matcher\n\n---\n\n### 쿼리함수\n\n쿼리는 페이지에서 요소를 찾기 위해 테스트 라이브러리가 제공하는 방법\n\n- getBy~: 쿼리에 대해 일치하는 노드를 반환, 일치하는 요소가 없거나 둘 이상의 일치가 발견되면 에러를 반환(둘 이상의 요소는 getAllBy~ 사용)\n\n- queryBy~: 쿼리에 대해 일치하는 노드 반환, 일치하는 요소가 없으면 null을 반환\n\n- findBy~: (getBy + waitFor)주어진 쿼리와 일치하는 요소가 발견되면 Promise를 반환 (둘 이상의 요소는 findAllBy~ 사용)\n\n- waitFor: 일정 기간 동안 기다리도록\n\n---\n\n### 린트\n\n```\n\"eslint-plugin-jest-dom\"\n\"eslint-plugin-testing-library\"\n```\n\n---\n\n### TDD(Test Driven Development)\n\n실제 코드를 작성하기 전에 테스트 코드를 먼저 작성\n\n### 간단한 카운팅 앱 만들어보기\n\n```js\ntest('Counter starts at 0', () =\u003e {\n  render(\u003cApp /\u003e);\n  // screen object로 원하는 엘리멘트에 접근(ID)\n  const counterElement = screen.getByTestId('counter');\n  // id가 counter인 엘리멘트의 텍스트가 0인가?\n  expect(counterElement).toHaveTextContent(0);\n});\n```\n\n```js\nimport './App.css';\nimport {useState} from 'react';\n\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003cheader className=\"App-header\"\u003e\n        \u003ch3 data-testid=\"counter\"\u003e{count}\u003c/h3\u003e\n      \u003c/header\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n- 버튼 추가하기\n\n```js\ntest('Minus Button', () =\u003e {\n  render(\u003cApp /\u003e);\n  const buttonElement = screen.getByTestId('minus-button');\n  expect(buttonElement).toHaveTextContent('-');\n});\n\ntest('Plus Button', () =\u003e {\n  render(\u003cApp /\u003e);\n  const buttonElement = screen.getByTestId('plus-button');\n  expect(buttonElement).toHaveTextContent('+');\n});\n```\n\n```js\n\u003cdiv\u003e\n  \u003cbutton data-testid=\"minus-button\"\u003e-\u003c/button\u003e\n  \u003cbutton data-testid=\"plus-button\"\u003e+\u003c/button\u003e\n\u003c/div\u003e\n```\n\n### FireEvent API\n\n유저가 발생시키는 액션(이벤트)에 대한 테스트\n\n- 버튼 이벤트 추가하기\n\n```js\ntest('When the + button is pressed, the counter change to 1', () =\u003e {\n  render(\u003cApp /\u003e);\n  const buttonElement = screen.getByTestId('plus-button');\n  // 버튼 클릭\n  fireEvent.click(buttonElement);\n  // plus 버튼 클릭시 counter 엘리먼트는 1\n  const counterElement = screen.getByTestId('counter');\n  expect(counterElement).toHaveTextContent(1);\n});\n\ntest('When the - button is pressed, the counter change to -1', () =\u003e {\n  render(\u003cApp /\u003e);\n  const buttonElement = screen.getByTestId('minus-button');\n  // 버튼 클릭\n  fireEvent.click(buttonElement);\n  // minus 버튼 클릭시 counter 엘리먼트는 -1\n  const counterElement = screen.getByTestId('counter');\n  expect(counterElement).toHaveTextContent(-1);\n});\n```\n\n```js\nconst [count, setCount] = useState(0);\n\nconst handlePlus = () =\u003e {\n  setCount((prevState) =\u003e prevState + 1);\n};\n\nconst handleMinus = () =\u003e {\n  setCount((prevState) =\u003e prevState - 1);\n};\n\nreturn (\n  \u003cdiv className=\"App\"\u003e\n    \u003cheader className=\"App-header\"\u003e\n      \u003ch3 data-testid=\"counter\"\u003e{count}\u003c/h3\u003e\n      \u003cdiv\u003e\n        \u003cbutton data-testid=\"minus-button\" onClick={handleMinus}\u003e\n          -\n        \u003c/button\u003e\n        \u003cbutton data-testid=\"plus-button\" onClick={handlePlus}\u003e\n          +\n        \u003c/button\u003e\n      \u003c/div\u003e\n    \u003c/header\u003e\n  \u003c/div\u003e\n);\n```\n\n- on/off 버튼 색상과 클릭시 -, +버튼 disabled\n\n```js\n\ntest('on/off button has blue color', () =\u003e {\n  render(\u003cApp /\u003e);\n  const buttonElement = screen.getByTestId('on/off-button');\n  expect(buttonElement).toHaveStyle({backgroundColor: 'blue'});\n});\n\ntest('Prevent -,+ button from being pressed when the on/off button is clicked', () =\u003e {\n  render(\u003cApp /\u003e);\n  const onOffButtonElement = screen.getByTestId('on/off-button');\n  fireEvent.click(onOffButtonElement);\n  const plusButtonElement = screen.getByTestId('plus-button');\n  const minusButtonElement = screen.getByTestId('minus-button');\n  expect(plusButtonElement).toBeDisabled();\n  expect(minusButtonElement).toBeDisabled();\n});\n```\n\n```js\n\u003cbutton data-testid=\"on/off-button\" style={{backgroundColor: 'blue'}} onClick={handleDisabled}\u003e\n  on/off\n\u003c/button\u003e\n```\n"])</script><script>self.__next_f.push([1,"1f:Tc66,"])</script><script>self.__next_f.push([1,"\n이번에 스터디를 하면서 처음 스토리북을 써보게 되었다.\n\n[https://storybook.js.org/](https://storybook.js.org/)\n\n\n스토리북은 디자인 시스템을 구축하고자하는 개발자들을 위해 제작되었다.\n\n**디자인 시스템은 왜 사용하는 걸까?**\n\n개발자 입장에서 가장 큰 이유는 디자이너, 프로젝트 매니저 등 팀 구성원과의 협업인것 같다.\n\n각 분야의 지식 차이를 줄이고 공통적으로 바라보는 것(UI)을 통해 생산성을 높일 수 있다.\n\n**디자인 시스템이 뭔데?**\n\n\u003cimg src=\"/assets/blog/javaScript/storybook.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n내가 생각하기에 디자인 시스템이란 하나의 프로덕트를 만드는데 있어서 디자인 적인 가이드 라인 및 디자인 원칙 = 색상, 아이콘, 타이포그래피 등 을 체계적으로 관리하고 문서화하는것 이라 생각한다.\n\n이것을 문서화하는데 도와주는 도구가 바로 스토리북이다.\n\n---\n\n우리는 먼저 공통적으로 사용되는 컴포넌트와, 자주 쓰이게 될만한 컴포넌트들을 작성하기로 시작했다.\n\n```shell\nnpx storybook init\n```\n\n본인이 사용하고자하는 프레임워크를 설치하고 위 명령어를 터미널에 입력하면 알아서 설치된다 \n\n```shell\nyarn storybook\n```\n\n로 시작하면 6006포트로 실행된다\n\n/src/components/Chip.tsx\n\n```js\n{...}\n\nconst Chip = ({\n  adornments = \"#\",\n  label = \"Chip\",\n  color = \"basic\",\n  variants,\n  outlined,\n  onDelete,\n}: ChipProps) =\u003e {\n  const props = { color, variants, outlined };\n\n  return (\n    \u003cStyledChip {...props}\u003e\n      {adornments \u0026\u0026 \u003cStyledChipAdornments\u003e{adornments}\u003c/StyledChipAdornments\u003e}\n      \u003cStyledChipLabel {...props}\u003e{label}\u003c/StyledChipLabel\u003e\n      {onDelete \u0026\u0026 (\n        \u003cCancelIconBtn value={label} onClick={onDelete}\u003e\n          \u003cStyledCancelIcon aria-hidden {...props} /\u003e\n        \u003c/CancelIconBtn\u003e\n      )}\n    \u003c/StyledChip\u003e\n  );\n};\n\nexport default Chip;\n\n{...}\n```\n\n배포 후 우리가 실제로 사용할 컴포넌트다\n\n다양한 색상으로 받기위해\n\n```ts\nexport type Color = \"basic\" | \"active\" | \"danger\" | \"warning\";\n```\n\n을 작성했다.\n\n\u003cimg src=\"/assets/blog/javaScript/storybook.gif\" width=\"100%\" alt=\"post image\"/\u003e\n\n/src/stories/Chip.stories.tsx\n\n```tsx\nimport { Meta, Story } from \"@storybook/react\";\nimport React from \"react\";\nimport { Chip, ChipProps } from \"../../../components/Chip\";\n\nexport default {\n  title: \"Components/Chip\",\n  component: Chip,\n} as Meta;\n\nexport const Default: Story\u003cChipProps\u003e = (args) =\u003e {\n  return \u003cChip {...args} /\u003e;\n};\n```\n\n여기서 우리가 만든 컴포넌트들을 문서화 할 수 있다\n\nargs을 넣어줄 수 있는데, 스토리북에서는 자동으로 설정해준다.\n\n```js\nDefault.args = {\n  color: \"active\",\n};\n```\n\n로 직접 정의할 수도 있다.\n\n우리는 npm으로 배포해 사용하기로 했다. 다음엔 배포과정과 빌드과정을 정리해야겠다.\n\n작성한 디자인 시스템을 기반으로 이번주부터 직접 개발에 들어가게된다.\n\n어떤점이 좋은지 차이가있는지 경험해보는 좋은 기회가 될거같다.\n"])</script><script>self.__next_f.push([1,"20:Td1c,"])</script><script>self.__next_f.push([1,"\nNextjs에서 styled-components를 사용하면 서버상에서 html을 불러온 뒤, hydrate과정에서 js를 입혀 스타일이 적용된다.\n\n이때 초기 페이지 로딩시 사용자가 보게 되는 화면은, 스타일링이 전혀 적용되지않은 html문서를 잠깐 보게 되는 문제가 있다.\n\n\u003cimg src=\"/assets/blog/javaScript/next-styled-component.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n네트워크 탭에서 받아온 문서(페이지)를 보면 style에 관한 정보는 없고, html만 내려온다.\n\n이럴때 **\\_document.tsx**를 커스텀해 사용할 수 있다.\n\n\\_document는 Page를 렌더링하는데 공통적으로 필요한 태그, 메타정보, 폰트 등을 커스텀 하는데 사용할 수 있다.\n\n또 document는 항상 서버상에서만 실행되므로 브라우저 및 클라이언트 단에서 포함된 코드들은 실행되지 않는다.\n\n---\n\n첫번째로 styled-components의 서버측 className과 클라이언트측 className을 동일하게 유지되도록 하기 위해서 next.config.js를 수정해야된다.\n\nnextjs 12.1버전 이상부터는 babel-plugin-styled-components를 사용하지 않아도 되고,\n\n```javascript\ncompiler: {\n  styledComponents: true\n},\n```\n\n만 작성해 주면 된다.\n\n두번째로 \n\n```javascript\nimport Document, {DocumentContext} from 'next/document'\nimport {ServerStyleSheet} from 'styled-components'\n\nclass MyDocument extends Document {\n  static async getInitialProps(ctx: DocumentContext) {\n    const sheet = new ServerStyleSheet()\n    const originalRenderPage = ctx.renderPage\n\n    try {\n      ctx.renderPage = () =\u003e\n        originalRenderPage({\n          enhanceApp: (App) =\u003e (props) =\u003e sheet.collectStyles(\u003cApp {...props} /\u003e)\n        })\n\n      const initialProps = await Document.getInitialProps(ctx)\n\n      return {\n        ...initialProps,\n        styles: [\n          \u003c\u003e\n            {initialProps.styles}\n            {sheet.getStyleElement()}\n          \u003c/\u003e\n        ]\n      }\n    } catch (error) {\n      throw error\n    } finally {\n      sheet.seal()\n    }\n  }\n}\n\nexport default MyDocument\n```\n\n\\_document.tsx 파일을 위처럼 작성해 주면 된다.\n\n\b\b위 코드는 초기 서버측에서 페이지를 불러올 때 스타일을 입혀 불러오도록 설정하는 코드다.\n\ngetInitialProps에서 받아온 ctx에서 renderPage객체를 찾아 볼 수 있는데, renderPage는 CSS-in-JS라이브러리를 커스텀할 때 만 사용하라고 공식문서에 나와있다.\n\nrenderPage 함수를 콘솔에 찍어보니, 우리가 보는 html페이지와 리액트컴포넌트들이 담겨있는 것 같다.\n\nstyled-components 라이브러리에서 ServerStyleSheet를 import하고 서버측에서 그려질 sheet를 새로 만든다.\n\n```javascript\nconst sheet = new ServerStyleSheet()\n```\n\n새로 만든 sheet에 renderPage에 있는 컴포넌트내부에 styled-components로 작성한 스타일들을 결합하고,\n\n```javascript\nctx.renderPage = () =\u003e\n  originalRenderPage({\n    enhanceApp: (App) =\u003e (props) =\u003e sheet.collectStyles(\u003cApp {...props} /\u003e)\n  })\n```\n\n기존에 html에 style태그를 추가한다.\n\n```javascript\nreturn {\n  ...initialProps,\n  styles: [\n    \u003c\u003e\n      {initialProps.styles}\n      {sheet.getStyleElement()}\n    \u003c/\u003e\n  ]\n}\n```\n\n\u003cimg src=\"/assets/blog/javaScript/next-styled-component(1).png\" width=\"100%\" alt=\"post image\"/\u003e\n"])</script><script>self.__next_f.push([1,"21:Te30,"])</script><script>self.__next_f.push([1,"\n프로젝트를 진행하면서, 프로필 페이지에 유저정보와 포인트, 펫정보, 관심사 등 세로로 길게~~배치된 UI, 각각의 정보들을 서버에서 데이터를 하나하나 받아와 보여줘야 했다.\n\n처음엔 아무생각없이 진행했다.\n\n프로필 페이지에 진입했을 때 각각 필요한 데이터를 서버에 4번이나 요청했고, 그대로 컴포넌트에 그렸다.\n\n그러다가💡 생각났는데,, 사용자에게 보이지않는 부분에 데이터도 받아오고 있었다.\n\n굳이 스크롤을 내리지도 않고 사용자에게 보이지도 않는 부분에 데이터까지 받아올 필요는 없었다.\n\n그럼 사용자가 스크롤을 내려 보고자하는 부분에 도달했을때, 아니면 도달하기 직전에 데이터를 불러와 보여주면 어떨까 싶었다.\n\n이전에 강의에서 이미지 Lazy로딩을 배웠었는데, 이미지 대신에 데이터 요청을 해보면 어떨까 생각했다.\n\n\u003cimg src=\"/assets/blog/javaScript/intersectionObserver.png\" width=\"100%\" alt=\"post image\" /\u003e\n\n컴포넌트가 마운트 되자마자 모든 데이터들이 요청된다.\n\n우선 훅을 하나 만들었다. ref객체가 감지되면 loaded가 true로 바뀌고, 더이상 감시가 중지된다.\n\n```tsx\nexport const useLazyRequest = () =\u003e {\n  const ref = useRef(null) as MutableRefObject\u003cHTMLDivElement\u003e\n  const [loaded, setLoaded] = useState\u003cboolean\u003e(false)\n\n  useEffect(() =\u003e {\n    const options = {}\n    const callback = (entries, observer) =\u003e {\n      entries.forEach((entry) =\u003e {\n        console.log(entry)\n        if (entry.isIntersecting) {\n          console.log('is Intersecting')\n          setLoaded(true)\n          observer.unobserve(entry.target) // 한번만 요청되도록 감시 중지\n        }\n      })\n    }\n    const observer = new IntersectionObserver(callback, options) // 객체 생성하기\n    observer.observe(ref.current)\n  }, [])\n\n  return {ref, loaded}\n}\n```\n\n사용하고자 하는 컴포넌트로 돌아와서,\n\n나는 데이터 요청에 SWR을 사용했다.\n\n[https://swr.vercel.app/ko](https://swr.vercel.app/ko)\n\n```tsx\n\n// SWR\nexport const useUserKeywords = (loaded: boolean) =\u003e {\n  const {data, isValidating, error} = useFetch(loaded ? PATH + '/keywords' : null, {\n    revalidateOnFocus: false,\n    revalidateIfStale: false,\n    shouldRetryOnError: false\n  })\n\n  return {\n    userKeywords: data,\n    isValidating,\n    error\n  }\n}\n```\n\nSWR은 위처럼 설정했다, SWR자체도 hook이기 때문에 useEffect나 다른 함수안에서 사용하지 못한다.\n\n```tsx\nconst {ref, loaded} = useLazyRequest()\nconst {userKeywords, isValidating, error} = useUserKeywords(loaded)\n\n\u003cContents ref={ref}\u003e\n        {isValidating ? (\n          \u003cLoading /\u003e\n        ) : (\n          \u003c\u003e\n           {...}\n          \u003c/\u003e\n        )}\n\u003c/Contents\u003e\n```\n\n4개의 섹션이 있는데, 페이지 진입시 1, 2번까지만 사용자에게 보이고 3, 4번의 컴포넌트를 위처럼 적용했다.\n\nref에 사용자의 view가 도달하면 userKeywords를 요청해 데이터를 받아온다.\n\n\u003cimg src=\"/assets/blog/javaScript/intersectionObserver(1).gif\" width=\"100%\" alt=\"post image\" /\u003e\n\n과거에는 getBoundingClientRect() 를 사용해 구현했다고 하는데, 리플로우 현상이나 성능면에서 보완하고자 요즘엔 intersection Observer를 사용해 타겟을 관찰한다고 한다.\n\n또 무한스크롤도 구현해 볼 수 있다. 페이지의 맨 마지막 요소에 도달했을 때, 요청하는 페이지 쿼리를 ++ 하면 쉽게 구현할 수 있다.\n\n다른 필요한 페이지에 적용해봐야겠다!\n"])</script><script>self.__next_f.push([1,"22:T1130,"])</script><script>self.__next_f.push([1,"\n\n이번 새로운 프로젝트에 사용하게 된 react-hook-form과 씨름하면서 정리해본 ref와 react-hook-form의 간단한 원리에 대해 정리해보자.\n\n---\n\n### **ref**란?\n\nReact에서는 props를 통해서만 부모와 자식간의 컴포넌트에 상호작용을 할 수 있다.\n\n자식 컴포넌트에 props를 전달해 props의 값이 변경되면 자식 컴포넌트는 다시 렌더링이 된다.\n\n그러나 props를 통한 방법이 아닌 직접적으로 자식 컴포넌트를 수정해야되는 일이 생길 수 있는데..\n\n### Ref를 사용해야 할 때\n\n-   포커스, 텍스트 선택영역, 혹은 미디어의 재생을 관리할 때.\n-   애니메이션을 직접적으로 실행시킬 때.\n-   서드 파티 DOM 라이브러리를 React와 같이 사용할 때.\n\n우선 DOM에 직접적으로 접근하는 방법은 건너 뛰고, react-hook-form과 관련된 **비제어 컴포넌트 제어**에 관해 알아보자.\n\n**react-hook-form**의 가장 큰 목적은 퍼포먼스이며, **비제어 컴포넌트**를 사용하고 있기 때문에 다른 라이브러리(formik, redux-form 등) 에 비해 타이핑이나 값이 변경될 때 리랜더링이 일어나는 양을 줄여준다.\n\n여기서 비제어 컴포넌트란, \n\nReact에서 제어하지 않고, 바닐라 JS를 이용해 제어하는 컴포넌트를 비제어 컴포넌트라 한다.\n\n쉽게말해 React가 관여하지 않는다. (재조정, 비교 등)\n\n이런 비제어 컴포넌트를 제어하기 위해서, DOM에 접근하는 역할을 ref가 한다.\n\n예를들어\n\n```javascript\nconst [test, setTest] = useState('')\n\u003cinput value={test} onChange={(e) =\u003e setTest(e.target.value)} /\u003e\n```\n\n위와같이 state로 상태를 관리하게 되면, state가 변하면서 이를 업데이트 하기 위해 계속해서 리렌더링이 된다.\n\n\u003cimg src=\"/assets/blog/javaScript/ref.gif\" width=\"100%\" alt=\"post image\"/\u003e\n\n이는 React에서 제어하는 컴포넌트다.\n\n그러면 굳이 인풋에 값만 변하는건데 불필요한 리렌더링이 필요하지 않을 수 있다.\n\n```\n  const inputRef = useRef(null)\n  const testHandler = (e) =\u003e {\n    inputRef.current.value = e.target.value\n  }\n    \u003cinput ref={inputRef} onChange={(e) =\u003e testHandler(e)} /\u003e\n```\n\n\u003cimg src=\"/assets/blog/javaScript/ref(1).gif\" width=\"100%\" alt=\"post image\"/\u003e\n\nref를 사용하면 인풋값이 변경되어도 리렌더링이 발생하지 않는다.\n\n---\n\n### Ref 와 함수형 컴포넌트\n\n-   함수 컴포넌트는 인스턴스가 없기 때문에 **함수 컴포넌트에 ref 어트리뷰트를 사용할 수 없습니다**.\n\n사실 위 예제는 클래스형 컴포넌트에서 작성해야 적합했지만, 함수형 컴포넌트에서도 ref는 사용할 수 있다.\n\n다만 상태값이 바뀔 때 마다 다시 실행되는 함수형 컴포넌트의 특성때문에 기존과는 다른 방식을 사용한다.\n\n위 예제에서 사용한 **useRef는 hook으로 함수의 렌더링의 상관없이** 상태 값을 유지한다.\n\n---\n\n### forwardRef\n\nreact-hook-form을 사용하면서 \n\n**Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?**\n\n이런 에러를 만나게 됐는데, ref 기반으로 구성된 react-hook-form이 ref를 **자식요소(인풋컴포넌트)에 전달**하기 때문에 발생한 에러였다.\n\nref는 React에서 props로 사용하지 못하는 것 중에 하나였는데, 대표적인 Key값과 동일하게 **props로 사용할 수 없다**.\n\nReact에서 ref를 props로 사용하려면 forwardRef를 사용해 자식요소로 ref를 전달할 수 있다.\n\n자식 컴포넌트를 forwardRef()함수로 감싸주고, props와 ref를 받아 사용할 수 있다.\n\n```\nconst Input = forwardRef((props, ref) =\u003e {\n  return \u003cinput ref={ref} /\u003e;\n});\n```\n\n추가로 eslint 에러나 개발자 도구에서 forwardRef사용시 이름이 나오지 않는 에러는\n\ndisplayName 속성에 이름을 설정하거나, 익명함수 대신 이름있는 함수를 넘겨 주면 된다.\n\n```\nInput.displayName = \"Input\";\n```\n\n```\nconst Input = forwardRef(function Input(props, ref) {\n  return \u003cinput ref={ref} /\u003e;\n});\n```\n\n---\n\nref는 특정 DOM에 접근해 애니메이션을 이용할때만 주로 사용했었는데, 이번 기회에 조금 더 자세하게 들여다 본것 같다.🤔\n"])</script><script>self.__next_f.push([1,"23:T18c7,"])</script><script>self.__next_f.push([1,"\n이번에 유지보수하면서 진행했던 TTS (Text-to-Speech)\n\n단어의 발음을 읽어주도록 해야했다.\n\n결국 Google TTS로 구현하긴 했지만, 처음에는 Speechsynthesis를 사용해 구현했었다.\n\nSppechsynthesis는 (음성 합성) Web Speech API이고 주어진 텍스트를 소리로 바꿔주는, 음성 서비스에 대한 컨트롤러 인터페이스이다.\n\n---\n\n### Speechsynthesis\n\nIE빼고 브라우저 거의 지원한다.\n\n```javascript\nspeechSynthesis.getVoices();\n```\n\n로 지원하는 음성 목록을 확인할 수 있다.\n\n\n\u003cimg src=\"/assets/blog/javaScript/speechsynthesis.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n문제는,, 브라우저마다 또는 OS마다 지원하는 음성이 달라서 모두 동일하지 못했다,\n\n그래서 모바일따로 웹따로 브라우저별로 목소리가 다르게 세팅되어 Google TTS로 바꾸게 되었다.\n\n```javascript\nconst speech = new SpeechSynthesisUtterance()\n\n// 음높이와 목소리 등 설정이 가능\nspeech.voice\nspeech.text\nspeech.lang\nspeech.pitch\nspeech.rate\nspeech.volume\n```\n\n```\n// speechSynthesisUtterance에 설정한 음성 실행\nwindow.speechSynthesis.speak(speech)\n```\n\n---\n\n### Google TTS\n\n두가지 방식이 있었다.\n\n클라이언트 라이브러리와 API\n\n클라이언트 라이브러리\n\n#### Node.js\n\n```javascript\nnpm install --save @google-cloud/text-to-speech\t//라이브러리 설치\n\n\n// Imports the Google Cloud client library\nconst textToSpeech = require('@google-cloud/text-to-speech');\n\n// Import other required libraries\nconst fs = require('fs');\nconst util = require('util');\n// Creates a client\nconst client = new textToSpeech.TextToSpeechClient();\nasync function quickStart() {\n  // The text to synthesize\n  const text = 'hello, world!';\n\n  // Construct the request\n  const request = {\n    input: {text: text},\n    // Select the language and SSML voice gender (optional)\n    voice: {languageCode: 'en-US', ssmlGender: 'NEUTRAL'},\n    // select the type of audio encoding\n    audioConfig: {audioEncoding: 'MP3'},\n  };\n\n  // Performs the text-to-speech request\n  const [response] = await client.synthesizeSpeech(request);\n  // Write the binary audio content to a local file\n  const writeFile = util.promisify(fs.writeFile);\n  await writeFile('output.mp3', response.audioContent, 'binary');\n  console.log('Audio content written to file: output.mp3');\n}\nquickStart();\n```\n\n구글의 샘플코드\n\n위 코드로 테스트해보니 output.mp3 파일이 만들어지고 이 파일을 재생하면 요청한 text가 재생됐다.\n\n하지만 파일도 필요없고, 음성만 클라이언트에서 받으면 됐기 때문에 조금 더 살펴봤는데, reponse 부분에서 arrayBuffer의 버퍼데이터가 찍혔고, 이 response 데이터를 바로 클라이언트로 보내줬다.\n\n#### React\n\n```javascript\n      const requestAudioFile = async (e) =\u003e {\n            const audioContext = new (window.AudioContext || window.webkitAudioContext)\n\n            const response = await axios({\n                method: 'get',\n                url: `http://localhost:4000/exam1`,\n                params: {test: e.target.ariaValueText},\n                responseType: 'arraybuffer'\n            })\n\n            // 버퍼 데이터 비동기 디코딩\n            const audioBuffer = await audioContext.decodeAudioData(response.data)\n\n            // 오디오 source 만들기\n            const gainNode = audioContext.createGain()\n            const source = audioContext.createBufferSource()\n\n            // 생성된 source에 재생할 데이터 선언\n            source.buffer = audioBuffer\n            source.connect(gainNode)\n\n            // 재생할 스피커에 source 넣기\n            gainNode.connect(audioContext.destination)\n            source.start()\n\n            console.log('responce', response.data);\n            console.log('audioContext', audioContext);\n            // -------------- //\n            const audioBuffer = await audioContext.decodeAudioData(decode);\n            console.log('audioBuffer', audioBuffer);\n            //create audio source\n              const gainNode = audioContext.createGain()\n              const source = audioContext.createBufferSource()\n            console.log('source : ', source);\n\n              source.buffer = audioBuffer\n              source.connect(gainNode)\n              gainNode.connect(audioContext.destination)\n\n            source.start();\n        }\n```\n\n읽혀야할 text를 params로 보냈고, Web Audio API 의 AudioContext를 사용해서 받아온 버퍼데이터를 읽도록 했다.\n\n근데 몇가지 문제가 더 있었는데, 모바일에서는 작동하지 않는것..audio 태그를 이용해 읽혀야 하기 때문에 버튼 커스텀이 되지 않았다.\n\n그래서 변경한게 API\n\n```\nPOST https://texttospeech.googleapis.com/v1/text:synthesize?key='Google API KEY'\n```\n\n```json\n{\n  \"input\":{\n    \"text\":\"Android is a mobile operating system developed by Google, based on the Linux kernel and designed primarily for touchscreen mobile devices such as smartphones and tablets.\"\n  },\n  \"voice\":{\n    \"languageCode\":\"en-gb\",\n    \"name\":\"en-GB-Standard-A\",\n    \"ssmlGender\":\"FEMALE\"\n  },\n  \"audioConfig\":{\n    \"audioEncoding\":\"MP3\"\n  }\n}\n```\n\n위처럼 작성해 POST요청을 보내면  \n\n```\n//NExAARqoIIAAhEuWAAAGNmBGMY4EBcxvABAXBPmPIAF//yAuh9Tn5CEap3/o\n...\nVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\n```\n\n음성이 base64 인코딩 형식으로 들어온다.\n\n받은 인코딩된 음성을\n\n```javascript\nconst [audioSource, setAudioSource] = useState(null)\n\nconst requestAudioFile = async (e) =\u003e {\n  const response = await axios.post(\n      // eslint-disable-next-line no-undef\n    `https://texttospeech.googleapis.com/v1/text:synthesize?key=${process.env.REACT_APP_GOOGLE_TTL}`,\n    {\n      input: {\n        text: e?.target?.ariaValueText\n      },\n      voice: {\n        languageCode: 'en-US',\n        name: 'en-US-Standard-H',\n        ssmlGender: 'FEMALE'\n      },\n      audioConfig: {\n        audioEncoding: 'LINEAR16',\n        speakingRate: 1\n      }\n    }\n  );\n  setAudioSource(new Audio(\"data:audio/wav;base64,\" + response.data?.audioContent));\n};\n\n    useEffect(() =\u003e {\n        audioSource?.play()\n    }, [audioSource])\n```\n\nnew Audio 오디오 객체를 이용해 오디오소스가 들어올때, 오디오를 만들고 재생시켰다.\n"])</script><script>self.__next_f.push([1,"24:Tf2b,"])</script><script>self.__next_f.push([1,"\n**[유동균님의 강의](https://www.inflearn.com/course/%EC%9B%B9-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%A6%AC%EC%95%A1%ED%8A%B8-1)를 보며 정리한 글 입니다.**\n\n---\n\n### 1\\. Layout Shift\n\n원인\n\n1\\. 사이즈가 정해져 있지 않은 이미지\n\n2\\. 사이즈가 정해져 있지 않은 광고\n\n3\\. 동적으로 삽입된 콘텐츠\n\n4\\. Web font (FOIT, FOUT)\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization-3-1.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n여러 이미지를 로드할 때, 먼저 불러온 이미지 자리를 나중에 불러온 이미지가 밀어내게 되면서 레이아웃 변경이 계속 발생한다.\n\n```js\n\u003cImageWrap\u003e\n  \u003cImage /\u003e\n\u003c/ImageWrap\u003e\n```\n\n이때 Wrap에 고정값을 정해주고 Image는 그 값을 따라가기만 하면 된다. 여기서는 16:9 비율로 지정하기 위해 9 / 16 = 56.25%로 높이를 잡고 Image를 그 안에 넣는 방식으로 했다.\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization-3-2.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n컨텐츠가 새로 들어오면서 기존 컨텐츠를 밀어내지 않도록 컨텐츠를 그려줄 곳에 미리 자리를 만들어 놓는것이다.\n\n---\n\n### 2\\. React-lazyload\n\n```shell\nnpm i react-lazyload\n```\n\n강의에서는 라이브러리를 사용했지만, 다음엔 스스로 구현해 포스팅해야겠다.\n\n스크롤이벤트를 사용하는 것 같다.\n\n---\n\n### 3\\. useSelect 렌더링 문제\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization-3-3.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n리액트 dev-tool에서 Highlight updates ... 를 체크해 컴포넌트가 렌더링되는걸 확인할 수 있다.\n\nuseSelector는 dispatch로 Redux Store가 변경되면 구독하고 있는 컴포넌트에 state가 변경되었다고 알려준다.\n\n그럼 컴포넌트에서는 기존 state와 업데이트된 state를 비교해 값이 다르면 다시 렌더링 하게 된다.\n\n여기서 비교하는 방식은 useSelector의 리턴값을 비교하는데\n\n```js\nconst { modalVisible, bgColor, src, alt } = useSelector(state =\u003e ({\n  modalVisible: state.modalVisible,\n  bgColor: state.bgColor,\n  src: state.src,\n  alt: state.alt,\n}));\n```\n\n리턴값을 오브젝트 형식으로 작성하면, 값을 생성할 때 마다 새로운 오브젝트를 만들기 때문에 매번 새롭게 렌더링하게 된다.\n\n```js\nconst modalVisible = useSelector(state =\u003e state.modalVisible)\nconst bgColor = useSelector(state =\u003e state.bgColor)\nconst src = useSelector(state =\u003e state.src)\nconst alt = useSelector(state =\u003e state.alt)\n```\n\n오브젝트를 새롭게 만들지 않도록 state를 쪼개고 새로운 Equality Function을 사용해야한다.\n\n```js\nconst { modalVisible, bgColor, src, alt } = useSelector(state =\u003e ({\n  modalVisible: state.modalVisible,\n  bgColor: state.bgColor,\n  src: state.src,\n  alt: state.alt,\n}), shallowEqual);\n```\n\n---\n\n### 4\\. Redux Reselect\n\nstate의 값들을 가지고 가공해야되는 값이 있을 때 useSelector내부에서 가공해 값을 준다.\n\n```js\nconst selectFilteredPhotos = createSelector([select값], (select값) =\u003e (가공할 결과를 리턴)\nconst photos = useSelector(selectFilteredPhotos)\n```\n\n또 메모이제이션 방식을 통해 값을 비교하므로 불필요한 계산도 없애준다.\n\nselect값이 같은 값으로 들어오면 미리 캐싱해둔 값과 비교해 값이 변하지 않으면 그대로 리턴한다.\n\n---\n\n### 5\\. Memoization 적용\n\n인풋에 따라 아웃풋에 나오는 값에 대해서 미리 저장해 놓는 기법이다.\n\na -\u003e A가 아웃풋이다 라고 할때, 다음번에 또 a가 들어오면 로직을 일일히 실행하지않고 저장해둔 값 A를 바로 리턴하게 된다.\n\n순수함수만 가능\n\n그렇다고 무지성으로 쓰는건 좋지 않다.\n\n메모이제이션이 불필요한 함수에 적용하는건 오히려 메모리 낭비가 될 수 있다.\n"])</script><script>self.__next_f.push([1,"25:T2721,"])</script><script>self.__next_f.push([1,"\n**[유동균님의 강의](https://inf.run/4zeg)를 보며 정리한 글 입니다.**\n\n---\n\n### 1\\. 이미지 지연(lazy) 로딩\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization-2-1.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n예제에서 네트워크를 6메가비트로 맞춰놓았다.\n\n제일 먼저 사용자에게 보여져야할 동영상이 이미지 보다 더 늦게 다운로드 되는 부분을 동영상이 먼저 다운로드 되도록 수정해야한다.\n\n-   이미지를 빠르게 다운로드\n-   **이미지를 나중에 다운로드, 동영상 먼저 다운로드**\n\n두번째 방법을 사용해 수정(image lazy)\n\n이미지를 필요할때(나중에, 보여지기 직전에) 로드되도록 해야한다.\n\n스크롤이 이미지가 있는 곳에 도달하면 이미지를 로드하고, 그렇지 않으면 보이지 않도록 해야하는데,\n\n이 방법은 사용자가 매번 스크롤을 할 때마다 이벤트함수가 호출되는 단점이 있다.\n\n이 문제를 해결하려면 **IntersectionObserver**로 해결할 수 있다. 즉 화면에 특정 이미지가 들어올 때만 함수를 호출하게 된다.\n\n[https://developer.mozilla.org/ko/docs/Web/API/Intersection\\_Observer\\_API](https://developer.mozilla.org/ko/docs/Web/API/Intersection_Observer_API)\n\n```js\nconst observer = new IntersectionObserver(callback, options)\nobserver.observe(element객체)\n```\n\n```js\n    const imgRef = useRef(null)\n\n   useEffect(() =\u003e {\n      const options = {}\n      const callback = () =\u003e {\n         console.log('callback')\n      }\n      const observer = new IntersectionObserver(callback, options)\n\n      observer.observe(imgRef.current)\n   }, [])\n\n\n   return (\n      \u003cdiv className=\"Card text-center\"\u003e\n         \u003cimg src={props.image} ref={imgRef} /\u003e\n         \u003cdiv className=\"p-5 font-semibold text-gray-700 text-xl md:text-lg lg:text-xl keep-all\"\u003e\n            {props.children}\n         \u003c/div\u003e\n      \u003c/div\u003e\n   )\n}\n```\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization-2-2.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n스크롤을 내려 이미지가 **보이거나 사라질때** 콘솔이 찍힌다.\n\n이미지가 보이는 그 순간에만 로드하려면 callback 함수에 entries와 observer객체를 넘겨주면 된다.\n\n```js\nuseEffect(() =\u003e {\n   const options = {}\n   const callback = (entries, observer) =\u003e {\n      entries.forEach(entry =\u003e {\n         if(entry.isIntersecting){\n            console.log('is Intersecting')\n         }\n      })\n   }\n   const observer = new IntersectionObserver(callback, options)\n\n   observer.observe(imgRef.current)\n}, [])\n```\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization-2-3.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n위와는 다르게 화면안에 이미지가 **보일 때만** 콘솔이 찍힌다.\n\n```js\n    const imgRef = useRef(null)\n\n    useEffect(() =\u003e {\n        const options = {}\n        const callback = (entries, observer) =\u003e {\n            entries.forEach(entry =\u003e {\n                if(entry.isIntersecting){\n                    console.log('is Intersecting', entry.target.dataset.src)\n                    entry.target.src = entry.target.dataset.src\n                    // 이미지가 들어오면 더이상 감시하지 않음\n                    observer.unobserve(entry.target)\n                }\n            })\n        }\n        const observer = new IntersectionObserver(callback, options)\n        // 이미지를 넣음\n        observer.observe(imgRef.current)\n    }, [])\n\n\n    return (\n        \u003cdiv className=\"Card text-center\"\u003e\n            \u003cimg data-src={props.image} ref={imgRef}/\u003e\n            \u003cdiv className=\"p-5 font-semibold text-gray-700 text-xl md:text-lg lg:text-xl keep-all\"\u003e\n                {props.children}\n            \u003c/div\u003e\n        \u003c/div\u003e\n    )\n}\n```\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization-2-4.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n동영상을 먼저 로드하고, 이미지를 불러옴\n\n---\n\n### 2\\. 이미지 사이즈 최적화\n\n위에서 지연로딩을 사용해 이미지를 불러오는 타이밍을 조절했지만 그래도 이미지 자체의 용량이 크다면 불러오는 속도가 느려질 수 밖에 없다.\n\n이미지 포맷, 확장자 종류\n\n- JPG를 **WEBP**(구글에서 나온 이미지 포맷, JPG에 비해서 화질이높고 용량이 낮음)로 변경,\n\n* 꼭 WEBP로 할필요는 없다 (**WEBP, WEBM**은 현재 잘 쓰지 않는다) 현재 지원하지않는 브라우저도 있음\n\n**picture** 태그로 이미지 분기(나중에 자세하게 배워보자)\n\n```html\n\u003cpicture\u003e\n   \u003csource  data-srcset={props.webp} type='image/webp'/\u003e\n   \u003cimg data-src={props.image} ref={imgRef}/\u003e\n\u003c/picture\u003e\n```\n\n이미지 포맷은 [https://squoosh.app/](https://squoosh.app/) 를 사용했다.\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization-2-5.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n예제에서 브라우저에 보일 크기는 300 x 300 이므로 **x2**를해 600 x 600으로 포맷\n\n이미지가 9.74MB에서 **21.9KB**로 줄었다.\n\n---\n\n### 3\\. 동영상 사이즈 최적화\n\n동영상이 메인 컨텐츠가 아닌 경우 적합\n\n동영상도 **WEBM**으로 포맷\n\n```html\n\u003cvideo\n   className=\"absolute translateX--1/2 h-screen max-w-none min-w-screen -z-1 bg-black min-w-full min-h-screen\"\n   autoPlay\n   loop\n   muted\n\u003e\n   \u003csource src={video_webm} type='video/webm' /\u003e\n   \u003csource src={video} type='video/mp4' /\u003e\n\u003c/video\u003e\n```\n\n---\n\n### 4\\. 폰트 최적화\n\n폰트도 리소스라 네트워크를 통해 받아온다.\n\n- 웹 폰트의 문제점\n\n**FOUT**(Flash of Unstyled Text) = 폰트를 다운로드 하기 전에는 **기본폰트로 컨텐츠**를 보여줌\n\n**FOIT**(Flash of Invisible Text) = 폰트가 다운로드 되기 전에는 **컨텐츠를 보여주지 않음**\n\n1. 폰트 적용 시점 컨트롤\n\n-   font-display 사용\n    \\- auto : 브라우저 기본 동작\n    \\- block : FOIT (timeout = 3s)\n    \\- swap : FOUT\n    \\- fallback : FOIT (timeout = 0.1s) 0.1초 후에도 불러오지 못하면 **기본 폰트 유지**, 이후에 캐시\n    \\- optional : FOIT (timeout = 0.1s) 이후 네트워크 상태에 따라 **기본폰트로 유지할지 웹폰트를 적용할지 결정**, 이후에 캐시\n\n```css\n@font-face {\n\tfont-family: BMYEONSUNG;\n\tsrc: url('./assets/fonts/BMYEONSUNG.ttf');\n\tfont-display: swap;\n}​\n```\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization-2-6.gif\" width=\"100%\" alt=\"post image\"/\u003e\n\n-   fontfaceobserver 라이브러리를 사용해 시각적인 효과\n\n```css\n@font-face {\n   font-family: BMYEONSUNG;\n   src: url('./assets/fonts/BMYEONSUNG.ttf');\n   font-display: block;\n}\n```\n\n```js\nconst [isFontLoaded, setIsFontLoaded] = useState(false)\n\nconst font = new FontFaceObserver('BMYEONSUNG');\n\nuseEffect(() =\u003e {\n   font.load().then(function () {\n      console.log('BMYEONSUNG has loaded');\n      setIsFontLoaded(true)\n   });\n}, [])\n\nreturn (\n    \u003cdiv className=\"...\" style={{opacity: isFontLoaded ? 1 : 0, transition: 'opacity 0.3s ease'}} \u003e\n        \u003cdiv className=\"...\"\u003e\n            {...}\n        \u003c/div\u003e\n    \u003c/div\u003e\n)\n```\n\n2. 폰트 사이즈 줄이기\n\n폰트 포멧 사이트 [https://transfonter.org/](https://transfonter.org/)\n\n- 웹폰트 포맷 사용 (파일 크기 = EOT \u003e TTF/OTF \u003e WOFF \u003e WOFF2)\n\n```css\n@font-face {\n   font-family: BMYEONSUNG;\n       /* 로컬에 폰트가 있으면 바로 적용*/\n   src: local('BMYEONSUNG'),\n       url('./assets/fonts/BMYEONSUNG.woff2') format('woff2'),\n       /* 지원하지 않는 브라우저 대응 */\n       url('./assets/fonts/BMYEONSUNG.woff') format('woff'),\n       url('./assets/fonts/BMYEONSUNG.ttf') format('truetype');\n   font-display: block;\n}\n```\n\n- local 폰트 사용\n\n- **Subset** 사용\n\n필요한 글자만 가져와서 사용 \"ABCDEFGHIJKLMNOPQR\"\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization-2-7.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n변환하지 않은 폰트는 포함되지 않음\n\n- **Unicode Range** 적용\n\n```css\n@font-face {\n   font-family: BMYEONSUNG;\n        /* 로컬에 폰트가 있으면 바로 적용*/\n   src: url('./assets/fonts/subset-BMYEONSUNG.woff2') format('woff2'),\n        /* 지원하지 않는 브라우저 대응 */\n        url('./assets/fonts/subset-BMYEONSUNG.woff') format('woff'),\n        url('./assets/fonts/BMYEONSUNG.ttf') format('truetype');\n   font-display: block;\n   unicode-range: U+0041;\n}\n```\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization-2-8.png\" width=\"100%\" alt=\"post image\"/\u003e\n\nSubset은 렌더링 하는 텍스트에 폰트가 필요하지 않아도 폰트를 로드하지만 unicode-range를 사용하면 폰트가 필요하지 않으면 로드하지 않는다\n\n- data-uri로 변환\n\nBase64 encode 해 불러오는 방식\n\n- **Preload**\n\n해당하는 페이지에 폰트가 필요하다는 것을 HTML에 작성\n\n```html\n\u003clink rel=\"preload\" href=\"BMYEONSUNG.woff2\" as=\"font\" type=\"font/woff2\" crossorigin\u003e\n```\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization-2-9.png\" width=\"100%\" alt=\"post image\"/\u003e\n\nCSS가 로드되기 전에 폰트가 먼저 로드됨\n\n---\n\n### 5\\. 캐시 최적화\n\n웹 브라우저는 크게 메모리 캐시, 디스크 캐시 두가지로 캐싱한다.\n\n**메모리 캐시는 RAM**에 저장, **디스크 캐시는 file로 데이터**를 저장\n\n- Cache-Control\n\n브라우저 이미지 요청 -\u003e 서버\n\n서버 -\u003e 브라우저에 이미지(캐시) 보냄\n\n* 서버에서 설정이 필요\n\n-   no-cache : 캐시를 사용하기 전에 서버에서 검사 후 사용 결정\n-   no-store : 캐시 사용 안함\n-   public : 모든 환경에서 사용\n-   private : 브라우저 환경에서만 캐시 사용, 외부 캐시 서버에서는 사용 불가\n-   max-age : 캐시의 유효시간\n\n- Node\n\n```js\nconst header = {\n    setHeaders: (res, path) =\u003e {\n    \tif(path.endsWith('.html')){\n        \tres.setHeader('Cache-Control', no-cache)\n        } else if(path.endsWith('.js') || path.endsWith('css') || path.endsWith('.webp')){\n        \tres.setHeader('Cache-Control', 'public, max-age=...'\n        } else {\n        \tres.setHeader('Cache-Control', 'no-store')\n        }\n    },\n}\n```\n"])</script><script>self.__next_f.push([1,"26:T1f48,"])</script><script>self.__next_f.push([1,"\n**[유동균님의 강의](https://www.inflearn.com/course/%EC%9B%B9-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%A6%AC%EC%95%A1%ED%8A%B8-1)를 보며 정리한 글 입니다.**\n\n---\n\n### 1\\. 구글 개발자 도구 Audits(LightHouse) 툴을 이용한 페이지 검사\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization1.png\" width=\"100%\" alt=\"post image\"/\u003e\n\u003cimg src=\"/assets/blog/javaScript/web-optimization2.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n**Opportunities** = 리소스의 관점(로딩성능)\n\n**Diagnostics** = 페이지의 실행 관점(렌더링)\n\n---\n\n### 2\\. 이미지 사이즈 최적화 - 로딩 성능\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization3.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n실제 이미지와 렌더링된 이미지의 크기가 다르다\n\n보통 이미지는 x2의 이미지를 사용\n\napi를 통해 받아온 이미지를 조절하려면?\n\n**Image CDN**(image processing Contents Delivery Network) - 이미지 가공 → 소비자\n\nCDN 구축은 진행하지 않았다.\n\n---\n\n### 3\\. performance\n\n크롬 개발자도구 -\u003e 성능에서 새로고침을 누르면 페이지의 작업을 분석해준다.\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization4.png\" width=\"100%\" alt=\"post image\"/\u003e\n\u003cimg src=\"/assets/blog/javaScript/web-optimization5.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n1.  HTML파싱\n2.  JS 로드\n3.  \b첫 페인팅 이후 API 호출\n\n- 리액트는 프레임차트에서 각 컴포넌트마다 실행되는 시간이 보여진다.\n\n---\n\n### 4\\. Route-based code Splitting\n\n코드 스플릿팅은 webpack, rollup 등과 같은 모듈 번들러를 이용하여 만들어진 하나의 번들 파일을 여러 개의 번들 파일로 나누는 것을 의미한다.\n\n하나의 번들파일을 여러개로 나누면 그만큼 로드 속도가 빨라진다.\n\n```js\nimport React, {Suspense, lazy} from 'react'\nimport { Switch, Route } from 'react-router-dom'\nimport './App.css'\n// import ListPage from './pages/ListPage/index'\n// import ViewPage from './pages/ViewPage/index'\n\nconst ListPage = lazy(() =\u003e import('./pages/ListPage/index'))\nconst ViewPage = lazy(() =\u003e import('./pages/ViewPage/index'))\n\nfunction App() {\n  return (\n    \u003cdiv className=\"App\"\u003e\n        \u003cSuspense fallback={\u003cdiv\u003e로딩 중...\u003c/div\u003e}\u003e\n          \u003cSwitch\u003e\n            \u003cRoute path=\"/\" component={ListPage} exact /\u003e\n            \u003cRoute path=\"/view/:id\" component={ViewPage} exact /\u003e\n          \u003c/Switch\u003e\n        \u003c/Suspense\u003e\n    \u003c/div\u003e\n  )\n}\n\nexport default App\n```\n\nimport()를 **lazy**라는 함수 안에 넣고, **Suspense**라는 컴포넌트로 관리를 해줄 수 있다.\n\n데이터가 로딩중에 유저에게 비어있는 컴포넌트가 보이게 되는데, Suspense를 사용해서 이 로딩중인 상태일 때 다른 컴포넌트를 보여줄 수 있다.\n\nSuspense는 fallback을 받아 import하는 도중에 띄어준다.\n\n페이지가 로드될 때 그 페이지 안에서 보이지 않는 컴포넌트가 존재할 수 있는데, 이 부분을 스플리팅해 관리 할 수도 있다.\n\n---\n\n### 5\\. 애니메이션 최적화\n\n일반적인 모니터는 초당 60FPS, 브라우저도 초당 60FPS로 화면을 그리게 된다.\n\n여기서 브라우저가 60FPS 아래로 그리게 된다면 쟁크 현상이 발생함.\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization6.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n1. DOM + CSSOM\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization7.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n2. Render Tree\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization8.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n위 DOM과 CSSOM을 조합해 RenderTree를 만들어 낸다.\n\n3. Layout\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization9.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n위치나 크기를 계산해 화면에 레이아웃을 그린다.\n\n4. Paint\n\n이렇게 그려진 레이아웃위에 색을 채워넣음\n\n5. Composite\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization10.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n각 레이어들을 합성하는 과정\n\n이 전체의 과정을 Critical Rendering Path, Pixel Pipeline 이라고 부른다.\n\n이 완성된 상태에서 변화가 생긴다면 처음으로 돌아가 다시 이 전체의 과정을 거치게 된다.\n\n- width, height가 변경되면, **1 -\u003e 2 -\u003e 3 -\u003e 4 -\u003e 5** 모두 실행되게 된다 **(Reflow)**\n\n- 크기나 위치가 아니라 color, background-color(색깔)이 변경됐을땐 **1 -\u003e 2 -\u003e 4 -\u003e 5** **(Repaint)**\n\n- transform, opacity 등(GPU가 관여하는 속성) 변경일 때 **1 -\u003e 2 -\u003e 5**\n\n따라서 transform, opacity 등(GPU가 관여하는 속성)을 사용하는게 가장 빠르고 끊김없이 보여줄 수 있다.\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization11.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n---\n\n### 6\\. 컴포넌트 Lazy Loading, Preload\n\n위에서 했던것 처럼 이미지를 보여주는 모달만 따로 스플릿팅 할 수있다.\n\n```js\nimport React, { useState, Suspense, lazy } from 'react'\nimport styled from 'styled-components'\nimport Header from './components/Header'\nimport InfoTable from './components/InfoTable'\nimport SurveyChart from './components/SurveyChart'\nimport Footer from './components/Footer'\n\nconst LazyImageModal = lazy(() =\u003e import('./components/ImageModal'))\n\nfunction App() {\n    const [showModal, setShowModal] = useState(false)\n\n    return (\n        \u003cdiv className=\"App\"\u003e\n            \u003cHeader /\u003e\n            \u003cInfoTable /\u003e\n            \u003cButtonModal onClick={() =\u003e { setShowModal(true) }}\u003e올림픽 사진 보기\u003c/ButtonModal\u003e\n            \u003cSurveyChart /\u003e\n            \u003cFooter /\u003e\n            \u003cSuspense fallback={null}\u003e\n                {showModal ? \u003cLazyImageModal closeModal={() =\u003e { setShowModal(false) }} /\u003e : null}\n            \u003c/Suspense\u003e\n        \u003c/div\u003e\n    )\n}\n```\n\n#### Lazy Loading의 단점\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization12.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n우리가 모달을 클릭한순간 모달에 관련된 파일을 불러오고 JS를 Evaluate한다.\n\n이게 끝나고 실제로 모달을 띄우는 코드가 실행된다.\n\n최초 페이지에서는 성능이 조금 빨라졌지만 모달을 띄울 때는 오히려 성능이 더 느려졌다.\n\n#### **\\- 컴포넌트 Preload**\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization13.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n이를 개선하기 위해서 모달을 열기 이전에 모달과 관련된 코드를 미리 로드해 둔다.\n\n문제는 사용자가 모달을 언제 클릭할지 모르기 때문에 언제 미리 로드할지 애매하다.\n\n#### 타이밍\n\n1. 버튼 위에 마우스를 올려 놨을 때\n\n```js\nconst handleMouseEnter = () =\u003e {\n    const Component = import('./components/ImageModal')\n}\n\u003cButtonModal onClick={() =\u003e { setShowModal(true) }} onMouseEnter={handleMouseEnter}\u003e올림픽 사진 보기\u003c/ButtonModal\u003e\n```\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization14.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n2. 최초 페이지 로드가 되고, 모든 컴포넌트의 마운트가 끝났을 때(ComponentDidMount)\n\n\u003cimg src=\"/assets/blog/javaScript/web-optimization15.png\" width=\"100%\" alt=\"post image\"/\u003e\n\n```js\nuseEffect(() =\u003e {\n    const Component = import('./components/ImageModal')\n}, [])\n```\n\n지금은 단일 컴포넌트를 미리 import 하지만 여러 컴포넌트를 Preload해줘야 할 때는\n\n```js\nfunction lazyWithPreload(importFunction){\n    const Component = React.lazy(importFunction)\n    Component.preload = importFunction\n    return Component\n}\n\nconst LazyImageModal = lazyWithPreload(() =\u003e import('./components/ImageModal'))\n```\n\n```js\nuseEffect(() =\u003e {\n    LazyImageModal.preload()\n}, [])\n```\n\n처럼 사용할 수 있다.\n\n#### **\\- 이미지 Preload**\n\n**new Image()**\n\n```js\nuseEffect(() =\u003e {\n    LazyImageModal.preload()\n\n    const img = new Image()\n    img.src = 'url'\n}, [])\n```\n\n주의할점은 이미지는 모듈과 다르게 필요할 때 마다 그때그때 매번 보내기 때문에\n\n사용하는 이미지에 캐시가 제대로 걸려있는지 확인할 필요가 있다.\n"])</script><script>self.__next_f.push([1,"27:T2416,"])</script><script>self.__next_f.push([1,"\n\n####\n**[Svelte vs React: Ending the Debate](https://massivepixel.io/blog/svelte-vs-react/ \"Svelte vs React: Ending the Debate\")를 읽으며 정리한 글입니다.**\n\n---\n\n## 리액트\n\n리액트는 페이스북에서 자체적으로 사용하기 위해 만든 라이브러리이며, 지금도 페이스북에서 관리하고 있다.\n\n처음 접하는 사람도 배우기가 쉽고, 개발속도도 빠르며 많은 개발자들이 사용하는 만큼 참고할 만한 사례들이 많다.\n\n또 가장 큰 특징은 재사용이 가능한 컴포넌트를 사용해 인터페이스를 구성하고, Virtual DOM을 사용해 앱의 성능을 향상시킨다는 것이다.\n\n---\n\n### 스벨트\n\n스벨트는 최근에 등장한 언어이고, 리액트, 뷰 등의 기존 프레임워크 및 라이브러리를 보완하고자 2016년에 출시되었다.\n\nRich Harris가 개발했으며, 스벨트의 멤버들이 관리하고, 현재 스포티파이, 어베스트, 등의 회사에서 사용하고 있다.\n\n스벨트의 공식사이트에서는 프레임워크라 소개하고 있지만 사실 컴파일러와 유사하다.\n\n가볍고 빠른 앱을 만들기 위해 가능한 적은 양의 JS코드를 생성하고 적절한 최적화를 보장한다.\n\n---\n\n\\- 등장 배경\n\n리치 해리스는 템플릿 기반 UI 라이브러리인 리액티브의 개발자다. 해리스는 이 언어를 그닥 좋아하지 않았고, JS는 덩치가 커 모바일 환경에서는 부담이 크고 치명적인 단점이 있으며 이를 해결하지 못했기 때문이다.\n\n### 스벨트와 리액트의 차이점\n\n\u003cimg src=\"/assets/blog/javaScript/svelte.png\" width=\"100%\" alt=\"post image\"/\u003e\n\u003cimg src=\"/assets/blog/javaScript/svelte(1).png\" width=\"100%\" alt=\"post image\"/\u003e\n\n## 스벨트의 장점\n\n#### 1\\. 스벨트가 더 성능이 좋다.\n\n스벨트는 **리액트, 뷰, 앵귤러 보다 더 좋은 성능**을 보여준다.\n\n속도, 로딩, 메모리 등 모든 테스트에서 스벨트가 우위에 있다.\n\n그 이유는 스벨트가 런타임이 아닌 빌드 타임에 애플리케이션 코드를 해석하기 때문이다.\n\n또 HTML, CSS, JS가 최적화된 작은 번들로 컴파일이 되기 때문에 스벨트는 앱 비즈니스 로직 처리에만 신경쓰면 된다.\n\n다른 프레임워크는 브라우저가 무거운 작업을 수행할 수 밖에 없도록 강제하므로 모든 부분에서 느려진다.\n\n또 가장 큰 이유는 Virtual DOM이 없다는 것이다.\n\n#### 2\\. 스벨트는 Virtual DOM을 \b비교하지 않는다.\n\n리액트에서는 Virtual DOM을 사용해 좋은 성능을 제공했고, 뷰도 이것을 보고 큰 영향을 받았다.\n\n여기서 Virtual DOM(가상 돔)이란 사용자 인터페이스에서 발생한 모든 변경 사항에 대한 문서 객체 모델(Document Object Model)을 메모리에 유지하는 **가상 임시 저장소**이다.\n\n실제 DOM을 사용하면 각각의 변경 사항이 발생할 때마다 DOM이 이를 반영하기 때문에 애플리케이션의 속도가 느려질 수 밖에 없다.\n\n반면에 가상 DOM은 실제 DOM의 변경사항을 업데이트하고 렌더링하는 가장 효율적인 방법을 찾을 때까지 해당 프로세스를 지연시킨다.\n\n이를 **조정(reconciliation) 프로세스 또는 비교(diffing)**라고 한다.\n\n스벨트는 꼭 가상 DOM을 사용해야만 뛰어난 성능을 달성할 수 있다라는 점에 동의하지 않았고, 이를 증명했다.\n\n#### 3\\. 스벨트가 더 반응이 뛰어나다.\n\n리액트는 선언적(declarative) 언어로써 어떠한 결과를 얻기 위해 각 단계를 모두 정의하는 대신에 원하는 결과만 지정하고 나머지는 리액트가 알아서 처리한다.\n\n그러나 값이 변경되었을때 자동으로 DOM에 반영하지 않는다. 리액트는 정해진 일정에 따라 컴포넌트를 업데이트 한다. setState, Hook을 사용하지 않으면 제대로 반영되지 않는다.\n\n스벨트도 이와 비슷하게 동작하지만 업데이트 명령을 받았을 때 동작한다. 그전까지는 발생한 모든 변경 사항이 한번에 처리된다.\n\n그러나 고려해야할 부분은 **반응형 선언문과 변수**이다. 반응형 선언문(reactive delaration)은 업데이트가 발생하는 동안 자동으로 로직을 다시 계산하는 역할을 한다. 그리고 반응형 변수는 일단 선언하면, 변경이 발생할 때마다 다른 변수들도 자동으로 변경한다. 이는 $ 기호를 추가하는 것 만으로 쉽게 가능하다.\n\n#### 4\\. 스벨트의 컴포넌트는 약간 다르게 처리된다.\n\n우선 스벨트는 컴포넌트를 내보내기 위해 **아무런 동작도 할 필요가 없다**. 스벨트가 자동으로 export해주기 때문이다. 이에 반해 리액트에서는 이를 수동으로 수행해야 된다.\n\n또 스벨트는 **스타일 태그에서 컴포넌트의 범위를 지정**하므로 유연한 스타일 지정을 할 수 있다.\n\n또 컴파일 단계에서 생성하므로 고유한 클래스를 작성하는데 애쓸 필요가 없다.\n\n#### 5\\. 스벨트에는 외부 라이브러리가 필요하지 않다.\n\n리액트는 뷰 영역에 초점을 맞춘 가벼운 라이브러리이며, 상태관리나 애니메이션을 구현하려면 외부 라이브러리를 사용해야 한다.\n\n이것이 꼭 나쁜것은 아니며 기능이 거의 없는 소규모 프로젝트의 경우에는 완벽할 수 있다.\n\n그러나 스벨트에는 앱의 크기를 늘리지 않으면서도 효과, 전환, 애니메이션 등이 내장되어 있어 필요한 부분만 불러오면 된다.\n\n또 스벨트는 다음과 같이 **상태 관리**를 할 수 있다.\n\n-   **컨텍스트 API**: 컴포넌트가 서로 통신하며 데이터를 전달 할 때\n-   **스벨트 스토어(Svelte Store)**: 컴포넌트가 대량의 데이터 전달하지 않고 통신해야 할 때\n-   **쓰기 가능 저장소(Writable Store)**: 객체가 여러 컴포넌트에 접근해야 할 때\n-   **읽기 가능 저장소(Readable Store)**: 사용자가 데이터를 조작하는 것을 원하지 않을 때\n\n\n#### 6\\. 스벨트가 더 가볍다.\n\nGZIPPED(압축된) 버전의 리액트는 **42.2KB**(ReactDOM포함), 스벨트는 **1.6KB** 이다.\n\n#### 7\\. 스벨트는 더 빠른 웹 개발을 제공한다.\n\n리액트의 개발 속도는 너무 빠르다 못해 이를 단점 중 하나로 인용되기도 한다.\n\n하지만 스벨트의 개발 속도는 이보다 더 빠르다.\n\n컴파일을 통해 생성된 코드는 리액트보다 짧고 읽기도 쉽다. 더 적은 수의 코드로 비슷한 결과를 얻어 낼 수 있으며, 이는 유지보수와 디버깅이 더 쉬워진다는 것을 의미한다.\n\n#### 8\\. 스벨트가 더 배우기 쉽다.\n\n리액트와 스벨트 둘 다 HTML, CSS, JS에 대한 지식이 필요하다.\n\n그러나 리액트에서는 JS에 대한 XML과 유사한 **JSX**를 배워야하지만, 스벨트는 더 쉬운 구문을 사용해 이해하기 쉬운 **자체 템플릿 언어**를 가지고 있다.\n\n## 스벨트의 단점\n\n#### 1\\. 커뮤니티 규모가 작다.\n\n리액트는 많은 사용과 큰 인기로 커뮤니티 규모도 크고 많은 무료 강좌와 가이드 등을 쉽게 구할 수 있고, 개발자 도구(React Revdloper, Redux DevTools 등) 생산성 향상에 도움을 주는 도구들이 많이있다.\n\n그러나 스벨트는 리액트 규모만큼의 커뮤니티와 기술 지원을 기대하기 어렵다.\n\n특히 **플러그인, 통합, IDE에 대한 부족한 지원**이 가장 큰 장애물이고, 문제가 발생하면 사용자에게 도움을 주지 못할 수도 있다.\n\n#### 2\\. 스벨트는 기업이 지원하지 않는다.\n\n리액트는 페이스북이 지원하고 있고, 페이스북에서 직접 사용할 목적으로 만들고 관리를 하고 있다.\n\n또 페이스북은 리액트의 지속적인 업데이트와 유지, 발전을 하기위한 자금을 가지고 있다. 이는 리액트에 미래에 대해 크게 걱정할 필요가 없다는 것을 의미한다.\n\n하지만 스벨트는 미래가 명확하지 않다. 작은 커뮤니티에서 유지 관리를 하고 있지만, 그들의 열정이 얼마나 오래갈지는 아무도 알 수 없다.\n\n또 스벨트에서 영감을 받은 또 다른 언어가 등장해 이 자리를 대체 할 수도 있다.\n\n#### 3\\. 스벨트는 대규모 웹에 거의 사용되지 않는다.\n\n스벨트는 최근에서야 대기업 애플리케이션에 규모를 지원하도록 성장했다. 이는 스벨트의 사용 사례가 많지 않다는걸 의미한다.\n\n## 결론\n\n스벨트는 많은 것을 제공한다.\n\n크기, 효율적은 코드, 빠른 성능으로 리액트, 뷰 또는 앵귤러에 강한 경쟁자로 보일 수 있다.\n\n하지만 스벨트는 아직 갈 길이 멀다. 지금까지는 인터넷 연결이 낮거나, 블로그, 포트폴리오 등 단순히 개인 웹사이트를 만드는 단일 페이지 애플리케이션을 구축하는데 사용하는 것이 좋다.\n\n또 큰 회사들의 기술 스택을 스벨트로 교체하기에는 많은 시간이 필요할 것이며 스벨트의 개발자들의 수요 또한 거의 없다.\n"])</script><script>self.__next_f.push([1,"28:T1085,"])</script><script>self.__next_f.push([1,"\n# 렌더링 최적화\n\n### 1\\. 컴포넌트를 맵핑할때는 key값으로 Index를 사용하지 말자\n\n리액트에서 컴포넌트를 맵핑할 때에는 고유 Key값을 부여해야한다.\n\n지금까지는 거의 Index를 고유한 Key값으로 사용했는데, 안좋은 습관인걸 알게됐다.\n\n배열 중간에 어떤 요소가 삽입되게 된다면, 그 이후의 요소들은 전부 Index가 변경되기 때문에 Key값도 변경될 뿐만 아니라 리마운트가 실행된다.\n\n또 이렇게 자주 Key값이 변경되게 된다면 서로 꼬이게 되는 버그도 발생할 수 있다.\n\n하지만 무조건 사용하면 안되는 것은 아니다.\n\n-   추가, 수정, 삭제 없이 단순히 렌더링만 하는 경우\n-   unique한 값이 없을 경우\n-   정렬이나 필터 요소가 없는 경우\n\n### 2\\. state는 어디에 선언해야 될까\n\n리액트는 특정 state나 Props가 변경되게 되면 선언된 컴포넌트에서 그 하위 컴포넌트들 까지 모두다 리렌더링이 된다.\n\n그렇기 때문에 state를 어디에 선언할지 잘 설계만 하더라도 불필요한 리렌더링을 막을 수 있다.\n\n또 객체 타입의 state는 최대한 쪼개어서 선언해 사용하는게 좋다.\n\n객체가 크고 복잡한 경우에 그 중 일부만 사용하더라도 관련된 모든 컴포넌트가 리렌더링 될것이다.\n\n### 3\\. useState의 함수형 업데이트\n\nsetState를 사용할때 새로운 상태를 파라미터로 넣어주는 대신에, 상태 업데이트를 어떻게 할지 정의해 주는 업데이트 함수를 넣을 수 있다.\n\n이렇게 하면 useCallback을 사용할 때 두 번째 파라미터로 넣는 배열에 값을 넣어주지 않아도 된다.\n\n```javascript\n// 기존\n  const onIncrease = useCallback(() =\u003e {\n    setNumber(number + 1);\n  }, [number]);\n\n\n// 함수형 업데이트\n  const onIncrease = useCallback(() =\u003e {\n    setNumber((number) =\u003e number + 1);\n  }, []);\n```\n\n### 4.Input Onchange 최적화\n\n보통 Input 태그에 onChange를 사용해 글을 입력하면 타이핑을 할 때마다 컴포넌트가 랜더링이 된다.\n\n이때 useMemo를 사용해주면 렌더링을 막을 수 있다.\n\n```javascript\nimport React, { useState } from \"react\";\n\nfunction InputSample() {\n  const [text, setText] = useState(\"\");\n  const [count, setCount] = useState(\"\");\n\n  const onChange = (e) =\u003e {\n    setText(e.target.value);\n  };\n\n  const onCount = () =\u003e {\n    console.log(\"카운트..\");\n    return count;\n  };\n\n  const outCount = onCount();\n\n  return (\n    \u003cdiv\u003e\n      \u003cinput onChange={onChange} value={text} /\u003e\n\n      \u003cdiv\u003e\n        \u003cb\u003e값: {text}\u003c/b\u003e\n        \u003cb\u003e{outCount}\u003c/b\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default InputSample;\n```\n\n\n```javascript\n{...}\n  const onChange = (e) =\u003e {\n    setText(e.target.value);\n  };\n\n  const onCount = () =\u003e {\n    console.log(\"카운트..\");\n    return count;\n  };\n\n  const outCount = useMemo(() =\u003e onCount(), [count]);\n\n  return (\n{...}\n)\n```\n\n\n### 5\\. memo, useMemo, useCallback\n\n#### \\- memo\n\nReact.memo는 Hook이 아니기 때문에 클래스형에서도 사용할 수 있다.\n\nmemo를 사용해 컴포넌트의 Props가 바뀌지 않았다면, 리렌더링하지 않도록 설정해 성능을 최적화 할 수 있다.\n\n```javascript\nimport React, { memo } from \"react\";\n\nfunction InputSample({ user }) {\n  console.log(\"Text component render\");\n  return (\n    \u003cdiv\u003e\n      \u003cb\u003e{user?.id}\u003c/b\u003e\n      \u003cb\u003e{user?.name}\u003c/b\u003e\n      \u003cb\u003e{user?.age}\u003c/b\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default memo(InputSample);\n```\n\n#### \\- useMemo, useCallback\n\n위에서 사용한 onCount의 함수가 간단한게 아니라 크고 복잡해 계산하는데 오래 걸리는 함수라고 가정한다면, 위 컴포넌트는 리렌더링 될 때마다 큰 계산을 계속 할 것이다.\n\nuseMemo \\[\\] 디펜던시에 데이터가 변할 때마다 함수를 실행할 수 있도록 count를 넣어주면 위 count가 변할 때마다 위 함수를 실행하게 된다.\n\nuseCallback도 비슷한 방식으로 작동 된다.\n\nuseMemo는 리턴되는 값을 memoize 시키는 반면에, useCallback은 함수 선언을 memoize 한다.\n\n```javascript\n  const addUser = useCallback(() =\u003e {\n    {...}\n  }, [users]);\n```\n"])</script><script>self.__next_f.push([1,"29:T1f82,"])</script><script>self.__next_f.push([1,"\n[리액트 문서](https://beta.reactjs.org/)를 정독하며 정리한 글\n영어문서라 조금 힘들었다...\n\n## 목업으로 시작\n\n다음과 같은 데이터를 받아오는 JSON API가 있다고 가정해보자.\n\n```json\n[\n  { \"category\": \"Fruits\", \"price\": \"$1\", \"stocked\": true, \"name\": \"Apple\" },\n  { \"category\": \"Fruits\", \"price\": \"$1\", \"stocked\": true, \"name\": \"Dragonfruit\" },\n  { \"category\": \"Fruits\", \"price\": \"$2\", \"stocked\": false, \"name\": \"Passionfruit\" },\n  { \"category\": \"Vegetables\", \"price\": \"$2\", \"stocked\": true, \"name\": \"Spinach\" },\n  { \"category\": \"Vegetables\", \"price\": \"$4\", \"stocked\": false, \"name\": \"Pumpkin\" },\n  { \"category\": \"Vegetables\", \"price\": \"$1\", \"stocked\": true, \"name\": \"Peas\" }\n]\n```\n\n-   목업\n\u003cimg src=\"https://beta.reactjs.org/images/docs/s_thinking-in-react_ui.png\" alt='mock' /\u003e\n\n### 1, UI를 컴포넌트로 나누기\n\u003cimg src=\"https://beta.reactjs.org/images/docs/s_thinking-in-react_ui_outline.png\" alt=\"ui\" /\u003e\n\n1.  FilterableProductTable (회색)은 전체 앱을 포함합니다.\n2.  SearchBar (파란색)은 사용자 입력을 받습니다.\n3.  ProductTable (라벤더)는 사용자 입력에 따라 목록을 표시하고 필터링합니다.\n4.  ProductCategoryRow (녹색)은 각 범주에 대한 제목을 표시합니다.\n5.  ProductRow (노란색)은 각 제품에 대한 행을 표시합니다.\n\n이를 계층별로 나누면\n\n-   FilterableProductTable\n-   SearchBar\n-   ProductTable\n-   ProductCategoryRow\n-   ProductRow\n\n위와같이 구성된다.\n\n\n\n### 2\\. React 정적 빌드\n\n이제 위와같은 계층구조를 만들고 앱을 구현할 차례이다.\n일반적으로 정적페이지를 만들고 상호작용되는 기능들을 추가하는게 더 쉬울 수 있다.\n또 보통은 FilterableProductTable(가장 상위) 부터 컴포넌트에서 하향식으로 작업하는게 쉽지만, 큰 프로젝트에서는 반대로 ProductRow 부터 상향식으로 작업하는게 쉬울 수 있다.\n\n```javascript\nfunction ProductCategoryRow({ category }) {\n  return (\n    \u003ctr\u003e\n      \u003cth colSpan=\"2\"\u003e\n        {category}\n      \u003c/th\u003e\n    \u003c/tr\u003e\n  );\n}\n```\n\n```javascript\nfunction ProductRow({ product }) {\n  const name = product.stocked ? product.name :\n    \u003cspan style={{ color: 'red' }}\u003e\n      {product.name}\n    \u003c/span\u003e;\n\n  return (\n    \u003ctr\u003e\n      \u003ctd\u003e{name}\u003c/td\u003e\n      \u003ctd\u003e{product.price}\u003c/td\u003e\n    \u003c/tr\u003e\n  );\n}\n```\n\n```javascript\nfunction ProductTable({ products }) {\n  const rows = [];\n  let lastCategory = null;\n\n  products.forEach((product) =\u003e {\n    if (product.category !== lastCategory) {\n      rows.push(\n        \u003cProductCategoryRow\n          category={product.category}\n          key={product.category} /\u003e\n      );\n    }\n    rows.push(\n      \u003cProductRow\n        product={product}\n        key={product.name} /\u003e\n    );\n    lastCategory = product.category;\n  });\n\n  return (\n    \u003ctable\u003e\n      \u003cthead\u003e\n        \u003ctr\u003e\n          \u003cth\u003eName\u003c/th\u003e\n          \u003cth\u003ePrice\u003c/th\u003e\n        \u003c/tr\u003e\n      \u003c/thead\u003e\n      \u003ctbody\u003e{rows}\u003c/tbody\u003e\n    \u003c/table\u003e\n  );\n}\n```\n\n```javascript\nfunction SearchBar() {\n  return (\n    \u003cform\u003e\n      \u003cinput type=\"text\" placeholder=\"Search...\" /\u003e\n      \u003clabel\u003e\n        \u003cinput type=\"checkbox\" /\u003e\n        {' '}\n        Only show products in stock\n      \u003c/label\u003e\n    \u003c/form\u003e\n  );\n}\n```\n\n```javascript\nfunction FilterableProductTable({ products }) {\n  return (\n    \u003cdiv\u003e\n      \u003cSearchBar /\u003e\n      \u003cProductTable products={products} /\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n```javascript\nconst PRODUCTS = [\n  {category: \"Fruits\", price: \"$1\", stocked: true, name: \"Apple\"},\n  {category: \"Fruits\", price: \"$1\", stocked: true, name: \"Dragonfruit\"},\n  {category: \"Fruits\", price: \"$2\", stocked: false, name: \"Passionfruit\"},\n  {category: \"Vegetables\", price: \"$2\", stocked: true, name: \"Spinach\"},\n  {category: \"Vegetables\", price: \"$4\", stocked: false, name: \"Pumpkin\"},\n  {category: \"Vegetables\", price: \"$1\", stocked: true, name: \"Peas\"}\n];\n```\n\n```javascript\nexport default function App() {\n  return \u003cFilterableProductTable products={PRODUCTS} /\u003e;\n}\n```\n\n\n\n\n### 3\\. 최소화되고 완전한 state 찾기\n\nstate를 구조화 하는데 가장 중요한 원칙은 DRY(Don't repeat yourself) 중복배제 이다.\n이제 위 애플리케이션의 모든 데이터를 쪼개서 생각해 보자.\n제품의 원래 목록\n사용자가 입력한 검색 input\n체크박스의 값\n필터링된 제품 목록\nQ. 다음 중 상태는 무엇인가?\n시간이 지나도 변하지 않는다면 state가 아니다.\n부모를 통해 props로 전달되면 state가 아니다.\n기존 컴포넌트의 props나 state기반으로 계산되면 state가 아니다. (이 부분은 해석이 조금 이해되지 않는다.)\n다시 살펴 보자.\n제품의 원래 목록은 props로 전달되므로 state가 아니다.\n검색 input는 시간이 지남에 따라 변경되고 아무 것도 계산할 수 없기 때문에 상태로 보인다.\n체크박스의 값은 시간이 지남에 따라 변경되고 아무 것도 계산할 수 없기 때문에 상태로 보인다.\n필터링된 제품 목록은 원래 제품 목록을 가져와서 검색 input과 체크박스의 값에 따라 필터링하여 계산할 수 있기 때문에 상태가 아니다.\n\n\n\n\n### 4\\. state가 어디에 있어야 하는지 확인\n\nReact는 단방향 데이터 흐름을 사용하여 상위 컴포넌트에서 하위 컴포넌트로 컴포넌트 계층 구조를 따라 데이터를 전달한다.\n위에서 아래로!\n\n-   애플리케이션의 각 state에 대해:\n\n1.  state를 기반으로 무언가를 렌더링 하는 모든 컴포넌트를 확인한다.\n2.  가장 가까운 부모 컴포넌트를 찾는다.\n\n-   state가 어디에 있어야 하는지 결정:\n\n1.  state를 바로 위 부모 컴포넌트에 놓을 수 있다.\n2.  또한 state를 공통된 부모 컴포넌트의 부모 컴포넌트에 놓을 수 있다.\n3.  state를 놓을 곳을 찾을 수 없으면 state를 유지하기 위한 새 컴포넌트를 만들고 최상위 컴포넌트 어딘가에 추가한다.\n4.  이전 단계에서 이 애플리케이션에서 검색 기능과 체크박스의 두 가지 상태를 찾았고, 이 예시 에서는 항상 함께 나타나므로 단일 상태로 생각하는 것이 더 쉽다.\n\n-   state를 사용하는 컴포넌트 찾기:\n\n1.  ProductTable의 state(검색 및 체크박스 값)를 기반으로 제품 목록을 필터링해야 한다.\n2.  SearchBar의 state(검색 및 체크박스 값)를 표시해야 한다.\n\n-   공통되는 상위 컴포넌트 찾기: 두 컴포넌트가 공유하는 첫 번째 부모 컴포넌트는 FilterableProductTable.(두 컴포넌트의 상위 부모 컴포넌트)\n-   state가 있는 위치 결정 : 검색 및 체크박스의 state 값을 FilterableProductTable(두 컴포넌트의 상위 부모 컴포넌트)에서 유지해야한다.\n-   따라서 state는 FilterableProductTable(두 컴포넌트의 상위 부모 컴포넌트)에 있어야 한다.\n\n```javascript\nfunction FilterableProductTable({ products }) {\n  const [filterText, setFilterText] = useState('');\n  const [inStockOnly, setInStockOnly] = useState(false);\n```\n\n그런 다음 props로 내려준다\n\n```javascript\n\u003cdiv\u003e\n  \u003cSearchBar\n    filterText={filterText}\n    inStockOnly={inStockOnly} /\u003e\n  \u003cProductTable\n    products={products}\n    filterText={filterText}\n    inStockOnly={inStockOnly} /\u003e\n\u003c/div\u003e\n```\n\n\n### 5\\. 반대방향의 데이터 흐름 추가하기\n\n마지막으로는 SearchBar, ProductTable에서 입력받은 state를 FilterableProductTable로 다시 전달해 줘야한다.\n\n```javascript\nfunction FilterableProductTable({ products }) {\n  const [filterText, setFilterText] = useState('');\n  const [inStockOnly, setInStockOnly] = useState(false);\n\n  return (\n    \u003cdiv\u003e\n      \u003cSearchBar\n        filterText={filterText}\n        inStockOnly={inStockOnly}\n        onFilterTextChange={setFilterText}\n        onInStockOnlyChange={setInStockOnly} /\u003e\n```\n\n```javascript\n// SearchBar\n\n\u003cinput\n  type=\"text\"\n  value={filterText}\n  placeholder=\"Search...\"\n  onChange={(e) =\u003e onFilterTextChange(e.target.value)} /\u003e\n```\n\n\n"])</script><script>self.__next_f.push([1,"2a:T1c8d,"])</script><script>self.__next_f.push([1,"\n## React Hook\n\nReact로 개발할 땐 클래스형 컴포넌트 보다 React 16.8 부터 도입된 Hook 기반 함수형 컴포넌트를 더 선호하여 개발하는 것 같다.\n\n기존 클래스형 컴포넌트는 여러 단계의 상속과 복잡성, 오류 등이 많았지만 Hook이 도입되면서 클래스형 컴포넌트가 가지고 있는 기능을 모두 사용할 수 있음은 물론이고 복잡성과 재사용성의 단점들까지도 해결됐다.\n\n---\n\n## 클로저(Closure)\n\nHook의 핵심은 JS의 클로저이다.\n클로저는..봐도봐도 잘 이해가 가지 않는다ㅠㅠ\n\n`클로저 = 함수 + 함수를 둘러싼 환경`\n이라고 말할 수 있는데, 자바스크립트는 함수 안에서도 함수를 선언할 수 있다.\n먼저 선언된 함수를 외부함수, 이후에 선언된 함수를 내부함수라 한다면 기본적으로 내부함수는 외부함수의 요소에 접근이 가능하다.\n즉 외부함수의 변수에 내부함수의 변수가 접근 할 수 있는 자바스크립트의 메커니즘이다.\n\n```javascript\nfunction outerFn() {\n  let outerVar = 'outer'\n  console.log(outerVar)\n\n  //클로저 함수\n  function innerFn() {\n    let innerVar = 'inner'\n    console.log(innerVar)\n  }\n  //클로저 함수 안에서는\n  //지역변수(innerVar)\n  //외부함수의 변수(outerVar)\n  //전역변수(globalVar)\n  //접근이 모두 가능하다.\n  return innerFn\n}\nlet globalVar = 'global'\nlet innerFn = outerFn()\ninnerFn()\n```\n\n---\n\n## useState\n\n```javascript\nfunction useState(initVal) {\n  let _val = initVal\n  const state = _val\n  const setState = newVal =\u003e {\n    _val = newVal\n  }\n  return [state, setState]\n}\nconst [count, setCount] = useState(1)\nconsole.log(count) // 1\nsetCount(2)\nconsole.log(count) // 1 (?)\n```\n\n위 함수에서 `count`는 한번 가져오고 끝난 값이기 때문에 즉각적으로 바뀌지 않는다.\n만약 `const state = _val` 부분을 함수로 바꾸고, 값을 쓰는게 아닌 호출해주는 식으로 바꾼다면 호출할 때마다 값을 가져오기 때문에 `setCount`가 반영된 값을 가져올 수 있다.\n\n```javascript\n// useState 안에서\n// ...\nconst state = () =\u003e _val\n// ...\nconst [count, setCount] = useState(1)\nconsole.log(count()) // 1\nsetCount(2)\nconsole.log(count()) // 2\n```\n\n`state`는 상단에 정의된 `_val`를 반환하고, `setState`는 전달 된 매개변수 `newVal`를 지역 변수로 설정한다.\n\n---\n\n### 함수형 컴포넌트에서 사용하기\n\n```javascript\nconst React = (function() {\n  function useState(initVal) {\n    let _val = initVal\n    const state = _val\n    const setState = newVal =\u003e {\n      _val = newVal\n    }\n    return [state, setState]\n  }\n  function render(Component) {\n    const C = Component()\n    C.render()\n    return C\n  }\n  return { useState, render }\n})()\nfunction Component() {\n  const [count, setCount] = React.useState(1)\n  return {\n    render: () =\u003e console.log(count),\n    click: () =\u003e setCount(count + 1),\n  }\n}\n// 아직까진 중간 과정이므로 제대로 동작하지 않는다.\nvar App = React.render(Component)\nApp.click()\nvar App = React.render(Component)\n```\n\n모듈패턴을 이용해 `React`라는 네임스페이스에 `useState`를 집어넣는다.\n그리고 DOM을 사용하진 않지만 가상의 컴포넌트를 만들어 `useState` 훅을 가져다 쓰는 방식이다.\n\n여기서 `count`가 제대로 동작하게 만들기 위해 `_val`로 쓰고 있던 변수를 `React` 내부로 끌어올리면 랜더링 이후 클릭해도 작동한다.\n\n```javascript\nconst React = (function() {\n  let _val\n  function useState(initVal) {\n    const state = _val || initVal\n    // ...\n  }\n  // ...\n})()\nvar App = React.render(Component) // 1\nApp.click()\nvar App = React.render(Component) // 2\nApp.click()\nvar App = React.render(Component) // 3\nApp.click()\nvar App = React.render(Component) // 4\n```\n\n---\n\n### 여러 개의 훅\n\n하지만 실제로 하나의 컴포넌트에서 여러 상태를 관리하기 위해 여러 훅을 사용하는데. `_val` 하나에 의존한 지금 상태로 `useState`를 두번 호출하게되면\n\n```javascript\nfunction Component() {\n  const [count, setCount] = React.useState(1)\n  const [text, setText] = React.useState('apple')\n  return {\n    render: () =\u003e console.log({ count, text }),\n    click: () =\u003e setCount(count + 1),\n    type: word =\u003e setText(word),\n  }\n}\nvar App = React.render(Component) // {count: 1, text: 'apple'}\nApp.click()\nvar App = React.render(Component) // {count: 2, text: 2}\nApp.type('banana')\nvar App = React.render(Component) // {count: 'banana', text: 'banana'}\n```\n\n중간에 값이 덮어씌워 진다. 이를 관리 하려면 각 값별로 배열에 담아 다루면 된다.\n\n```javascript\nconst React = (function() {\n  let hooks = []\n  let idx = 0\n  function useState(initVal) {\n    const state = hooks[idx] || initVal\n    const _idx = idx // 이 훅이 사용해야 하는 인덱스를 가둬둔다.\n    const setState = newVal =\u003e {\n      hooks[_idx] = newVal\n    }\n    idx++ // 다음 훅은 다른 인덱스를 사용하도록 한다.\n    return [state, setState]\n  }\n  function render(Component) {\n    idx = 0 // 랜더링 시 훅의 인덱스를 초기화한다.\n    const C = Component()\n    C.render()\n    return C\n  }\n  return { useState, render }\n})()\n```\n\n여기까지보면 왜 Hook에 기본 규칙이 있는지 알 수 있다.\n\n1.  최상위(Top Level)에서만 Hook을 호출\n2.  오직 React 함수 내에서 Hook을 호출\n\n---\n\n## useEffect\n\n`useEffect`를 사용하면 컴포넌트를 화면에 그린 후 실행될 함수를 정의할 수 있다.\n또 매번 `render`했을 때 최초 한 번만 실행되며 매 업데이트마다 실행된다.\n\n```javascript\nfunction Component() {\n  const [count, setCount] = React.useState(1)\n  const [text, setText] = React.useState('apple')\n  // 랜더링 시 최초에 한 번만 실행된다.\n  // 배열 안에 관찰하고자 하는 상태를 전달하면 그 상태에 반응하여 콜백이 실행된다.\n  React.useEffect(() =\u003e {\n    console.log('side effect')\n  }, [])\n  // ...\n}\n```\n\n```javascript\nfunction useEffect(cb, depArray) {\n  const oldDeps = hooks[idx] // 이미 저장되어있던 의존 값 배열이 있는지 본다.\n  let hasChanged = true\n  if (oldDeps) {\n    // 의존 값 배열의 값 중에서 차이가 발생했는지 확인한다.\n    // 실제로 리액트 구현체도 `Object.is` 로 값을 비교한다. 정확한 동작은 MDN 참고.\n    hasChanged = depArray.some((dep, i) =\u003e !Object.is(dep, oldDeps[i]))\n  }\n  // 값이 바뀌었으니 콜백을 실행한다.\n  if (hasChanged) {\n    cb()\n  }\n  // useEffect도 훅의 일부분이다. hooks 배열에 넣어서 관리해준다.\n  hooks[idx] = depArray\n  idx++\n}\n```\n\n위에 선언된 `React` 모듈 안에 `useEffect`함수를 정의한다.\n두번째 인자로 넣어둔 의존배열(dependency array)을 관찰하며 값이 변하면 콜백을 실행하고, 그렇지 않으면 실행하지 않는다.\n\n---\n\n## 참조\n\n위 글은 아래 두 블로그를 정독하며 정리하였습니다.\n\n[Deep dive: How do React hooks really work?](https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/)\n\n[Getting Closure on React Hooks](https://rinae.dev/posts/getting-closure-on-react-hooks-summary)\n"])</script><script>self.__next_f.push([1,"11:[\"$\",\"section\",null,{\"className\":\"flex flex-col-reverse md:relative md:flex-row\",\"children\":[[\"$\",\"$L12\",null,{\"posts\":{\"posts\":[{\"content\":\"$13\",\"data\":{\"title\":\"jwt 토큰 decode 하기\",\"date\":\"$D2023-08-31T00:00:00.000Z\",\"description\":\"jwt 토큰 decode 함수\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/javascript.png\"},\"slug\":\"jwt-decode\"},{\"content\":\"$14\",\"data\":{\"title\":\"Audio객체를 이용한 음악 재생\",\"date\":\"$D2023-05-27T00:00:00.000Z\",\"description\":\"Audio객체를 사용한 기업 과제 구현\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/logo192.png\"},\"slug\":\"audio\"},{\"content\":\"$15\",\"data\":{\"title\":\"디바운싱과 쓰로틀링\",\"date\":\"$D2023-05-13T00:00:00.000Z\",\"description\":\"디바운싱과 쓰로틀링의 차이를 구분하고 hook으로 구현\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/javascript.png\"},\"slug\":\"debouce-throttle\"},{\"content\":\"$16\",\"data\":{\"title\":\"GraphQl 써보기(1)\",\"date\":\"$D2023-04-29T00:00:00.000Z\",\"description\":\"GraphQl, Apollo Client를 사용\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/graphql.svg\"},\"slug\":\"graphql-1\"},{\"content\":\"$17\",\"data\":{\"title\":\"Next.js middleware와 getServerSideProps\",\"date\":\"$D2023-02-22T00:00:00.000Z\",\"description\":\"세션방식의 로그인 인증, middleware와 getServerSideProps를 사용해 구현한 기록\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/Nextjs.svg\"},\"slug\":\"next-middleware\"},{\"content\":\"$18\",\"data\":{\"title\":\"Nextjs에서 tailwind 써보기\",\"date\":\"$D2023-02-18T00:00:00.000Z\",\"description\":\"공식문서 보면서 tailwind 써보기\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/tailwind-css-icon.png\"},\"slug\":\"tailwindcss\"},{\"content\":\"$19\",\"data\":{\"title\":\"스벨트킷으로 블로그 만들어보기\",\"date\":\"$D2023-01-30T00:00:00.000Z\",\"description\":\"스벨트킷으로 블로그 만든 과정을 정리\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/svelte-icon.webp\"},\"slug\":\"svelte-blog\"},{\"content\":\"\\n### Provider 테스팅 해보기\\n\\n```js\\nrender(\u003cOptions optionType=\\\"scoops\\\" /\u003e, {wrapper: OrderDetailsProvider});\\n```\\n\\n테스트 wrapper에 Provider로 감싸주면 된다.\\n\\n여기서는 redux나 recoil 등 다른 라이브러리도 가능\\n\\n---\\n\\n전역적으로도 사용이 가능\\n\\n```js\\nimport {render} from '@testing-library/react';\\nimport {OrderDetailsProvider} from '../contexts/OrderDetails';\\n\\nconst renderWithContext = (ui, options) =\u003e render(ui, {wrapper: OrderDetailsProvider, ...options});\\n\\nexport * from '@testing-library/react';\\n\\nexport {renderWithContext as render};\\n```\\n\",\"data\":{\"title\":\"리액트 테스팅(4)\",\"date\":\"$D2023-01-02T00:00:00.000Z\",\"description\":\"jest와 react-testing-library\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/test.png\"},\"slug\":\"react-testing-4\"},{\"content\":\"$1a\",\"data\":{\"title\":\"리액트 조건부 렌더링에 대한 생각\",\"date\":\"$D2022-12-29T00:00:00.000Z\",\"description\":\"해외 블로그를 보며 정리한 조건부 렌더링에 대한 생각\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/logo192.png\"},\"slug\":\"conditional-rendering\"},{\"content\":\"$1b\",\"data\":{\"title\":\"useCallback, useMemo 무조건 좋은가?\",\"date\":\"$D2022-12-28T00:00:00.000Z\",\"description\":\"useCallback과 useMemo에 대한 생각 정리\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/logo192.png\"},\"slug\":\"usecallback-and-usememo\"},{\"content\":\"$1c\",\"data\":{\"title\":\"리액트 테스팅(3)\",\"date\":\"$D2022-12-26T00:00:00.000Z\",\"description\":\"jest와 react-testing-library\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/test.png\"},\"slug\":\"react-testing-3\"},{\"content\":\"$1d\",\"data\":{\"title\":\"리액트 테스팅(2)\",\"date\":\"$D2022-12-14T00:00:00.000Z\",\"description\":\"jest와 react-testing-library\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/test.png\"},\"slug\":\"react-testing-2\"},{\"content\":\"$1e\",\"data\":{\"title\":\"리액트 테스팅(1)\",\"date\":\"$D2022-12-10T00:00:00.000Z\",\"description\":\"jest와 react-testing-library\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/test.png\"},\"slug\":\"react-testing-1\"},{\"content\":\"$1f\",\"data\":{\"title\":\"Storybook 써보기\",\"date\":\"$D2022-10-11T00:00:00.000Z\",\"description\":\"스터디 하면서 처음 써본 Storybook\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/storybook.png\"},\"slug\":\"storybook\"},{\"content\":\"$20\",\"data\":{\"title\":\"Next.js styled-component 적용 문제에 대해(_document.tsx)\",\"date\":\"$D2022-08-22T00:00:00.000Z\",\"description\":\"next.js와 styled-component 사용시 발생한 에러\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/Nextjs.svg\"},\"slug\":\"next-styled-component\"},{\"content\":\"$21\",\"data\":{\"title\":\"IntersectionObserver로 데이터 요청해보기\",\"date\":\"$D2022-05-04T00:00:00.000Z\",\"description\":\"IntersectionObserver를 활용해 스크롤 위치에서 데이터 불러오기\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/logo192.png\"},\"slug\":\"intersectionObserver\"},{\"content\":\"\\n\\n####\\n**bundle-analyzer**는 빌드된 파일을 트리맵 형식으로 종류와 크기를 보여준다.\\n\\nnext에서 제공하는 bundle-analyzer\\n\\nnext.config.js\\n\\n```javascript\\nconst withBundleAnalyzer = require('@next/bundle-analyzer')({\\n  enabled: process.env.ANALYZE === 'true'\\n})\\n\\nmodule.exports = withBundleAnalyzer({\\n  compress: true,\\n  webpack(config, {webpack}) {\\n    const prod = process.env.NODE_ENV === 'production'\\n    const plugins = [...config.plugins]\\n    return {\\n      ...config,\\n      mode: prod ? 'production' : 'development',\\n      devtool: prod ? 'hidden-source-map' : 'eval',\\n      plugins\\n    }\\n  }\\n})\\n```\\n\\npackage.json / script\\n\\n```\\n\\\"build\\\": \\\"ANALYZE=true next build\\\",\\n```\\n\\n\u003cimg src=\\\"/assets/blog/javaScript/bundle-analyzer.png\\\" width=\\\"100%\\\" alt=\\\"bundle-analyzer\\\"/\u003e\\n\\n\\n이런식으로 html이 실행된다.\\n\\n서버와 클라이언트 두개의 창이 실행되는데 클라이언트 부분인 사용자에게 직접 보여질 부분이라, 서버 부분보다는 클라이언트 부분을 줄이는게 더 효과적이라고 한다.\\n\\n아이콘으로 쓰일 이미지를 두개쓰기싫어 svg를 컴포넌트화시켜 props로 색상을 변경시키게 했는데, 용량이 꽤 크다고 나왔다 거슬린다 🤔\\n\\n줄일수있는 방법을 찾아봐야겠다.\\n\\n또 나중에 최종 배포때는 번들된 JS 파일을 gz로 압축시켜 브라우저 쪽으로 보내주는 방법도 있다고 하는데, 나중에 시도해봐야겠다.\\n\",\"data\":{\"title\":\"next/bundle-analyzer\",\"date\":\"$D2022-02-22T00:00:00.000Z\",\"description\":\"next/bundle-analyzer로 번들 크기 확인하기\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/logo192.png\"},\"slug\":\"next-bundle-analyzer\"},{\"content\":\"$22\",\"data\":{\"title\":\"리액트 ref 와 forwardRef (with. react-hook-form)\",\"date\":\"$D2022-02-09T00:00:00.000Z\",\"description\":\"react-hook-form 라이브러리와 ref의 동작\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/logo192.png\"},\"slug\":\"ref-forwardRef\"},{\"content\":\"$23\",\"data\":{\"title\":\"Speechsynthesis \u0026 Google TTS\",\"date\":\"$D2022-01-22T00:00:00.000Z\",\"description\":\"프로젝트 진행하며 경험해본 Speechsynthesis \u0026 Google TTS\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/logo192.png\"},\"slug\":\"Speechsynthesis\"},{\"content\":\"$24\",\"data\":{\"title\":\"웹성능 최적화(3)\",\"date\":\"$D2022-01-04T00:00:00.000Z\",\"description\":\"웹성능 최적화3\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/logo192.png\"},\"slug\":\"web-optimization-3\"},{\"content\":\"$25\",\"data\":{\"title\":\"웹성능 최적화(2)\",\"date\":\"$D2022-01-03T00:00:00.000Z\",\"description\":\"웹성능 최적화2\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/logo192.png\"},\"slug\":\"web-optimization-2\"},{\"content\":\"$26\",\"data\":{\"title\":\"웹성능 최적화(1)\",\"date\":\"$D2022-01-01T00:00:00.000Z\",\"description\":\"웹성능 최적화1\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/logo192.png\"},\"slug\":\"web-optimization\"},{\"content\":\"$27\",\"data\":{\"title\":\"스벨트와 리액트\",\"date\":\"$D2021-12-12T00:00:00.000Z\",\"description\":\"스벨트와 리액트에 대해 정리한 글\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/svelte-icon.webp\"},\"slug\":\"svelte-react\"},{\"content\":\"$28\",\"data\":{\"title\":\"React 처럼 생각하기(2)\",\"date\":\"$D2021-12-12T00:00:00.000Z\",\"description\":\"리액트 문서 보며 정리\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/logo192.png\"},\"slug\":\"thinking-in-react-2\"},{\"content\":\"$29\",\"data\":{\"title\":\"React 처럼 생각하기\",\"date\":\"$D2021-11-20T00:00:00.000Z\",\"description\":\"리액트 문서 보며 정리\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/logo192.png\"},\"slug\":\"thinking-in-react\"},{\"content\":\"$2a\",\"data\":{\"title\":\"React Hook의 동작\",\"date\":\"$D2021-11-07T00:00:00.000Z\",\"description\":\"React Hook의 동작에 대해\",\"category\":\"javaScript\",\"titleImage\":\"/assets/postIcon/logo192.png\"},\"slug\":\"react-hook\"}],\"total\":26},\"page\":\"$undefined\",\"category\":\"javaScript\"}],[\"$\",\"ul\",null,{\"className\":\"relative top-0 flex h-fit min-w-fit flex-row flex-wrap gap-[20px] py-[20px] pl-0 md:sticky md:top-[100px] md:flex-col md:flex-nowrap md:py-0 md:pl-[30px]\",\"children\":[[\"$\",\"h2\",null,{\"className\":\"hidden text-[18px] font-bold md:inline\",\"children\":\"Category\"}],[[\"$\",\"li\",\"javaScript\",{\"children\":[\"$\",\"$Lc\",null,{\"className\":\"font-[600] text-black\",\"href\":\"/blog/javaScript\",\"children\":\"javaScript (26)\"}]}],[\"$\",\"li\",\"study\",{\"children\":[\"$\",\"$Lc\",null,{\"className\":\"text-gray700\",\"href\":\"/blog/study\",\"children\":\"study (2)\"}]}],[\"$\",\"li\",\"til\",{\"children\":[\"$\",\"$Lc\",null,{\"className\":\"text-gray700\",\"href\":\"/blog/til\",\"children\":\"til (1)\"}]}]]]}]]}]\n"])</script><script>self.__next_f.push([1,"9:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"Been blog - javaScript\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"Been dev-note\"}],[\"$\",\"meta\",\"3\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"4\",{\"name\":\"google-site-verification\",\"content\":\"BirkRt7C7FYMLW96RbXad2EtPdcl0-_ti9xCRkCHa5U\"}],[\"$\",\"meta\",\"5\",{\"name\":\"naver-site-verification\",\"content\":\"58945b2bbe2fe86252fa8c7b204b40f6019920e9\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:title\",\"content\":\"Been blog - javaScript\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:description\",\"content\":\"Been dev-note - javaScript\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:url\",\"content\":\"https://wonbeenna.github.io/blog/javaScript\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:site_name\",\"content\":\"Been blog\"}],[\"$\",\"meta\",\"10\",{\"property\":\"og:image\",\"content\":\"https://wonbeenna.github.io/favicon.png\"}],[\"$\",\"meta\",\"11\",{\"property\":\"og:image:width\",\"content\":\"800\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:image:height\",\"content\":\"600\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:image:alt\",\"content\":\"Been blog\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"15\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"16\",{\"name\":\"twitter:title\",\"content\":\"Been blog - javaScript\"}],[\"$\",\"meta\",\"17\",{\"name\":\"twitter:description\",\"content\":\"Been dev-note - javaScript\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:image\",\"content\":\"https://wonbeenna.github.io/favicon.png\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:image:width\",\"content\":\"800\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:image:height\",\"content\":\"600\"}],[\"$\",\"meta\",\"21\",{\"name\":\"twitter:image:alt\",\"content\":\"Been blog\"}],[\"$\",\"link\",\"22\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"192x192\"}],[\"$\",\"meta\",\"23\",{\"name\":\"next-size-adjust\"}]]\n"])</script><script>self.__next_f.push([1,"10:null\n"])</script></body></html>