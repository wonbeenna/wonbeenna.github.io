2:I[8451,["438","static/chunks/438-20a73b8af0ca1535.js","411","static/chunks/app/page/%5Bpage%5D/page-10f5b8e52537b5e8.js"],""]
c:I[5250,["438","static/chunks/438-20a73b8af0ca1535.js","411","static/chunks/app/page/%5Bpage%5D/page-10f5b8e52537b5e8.js"],""]
d:I[5613,[],""]
f:I[1778,[],""]
10:I[5935,["438","static/chunks/438-20a73b8af0ca1535.js","185","static/chunks/app/layout-46965708893096b1.js"],""]
11:I[4840,["438","static/chunks/438-20a73b8af0ca1535.js","185","static/chunks/app/layout-46965708893096b1.js"],"Providers"]
12:"$Sreact.suspense"
13:I[6005,["438","static/chunks/438-20a73b8af0ca1535.js","185","static/chunks/app/layout-46965708893096b1.js"],"NoSSR"]
14:I[286,["438","static/chunks/438-20a73b8af0ca1535.js","185","static/chunks/app/layout-46965708893096b1.js"],""]
15:I[1749,["438","static/chunks/438-20a73b8af0ca1535.js","185","static/chunks/app/layout-46965708893096b1.js"],"Image"]
16:I[9137,["438","static/chunks/438-20a73b8af0ca1535.js","185","static/chunks/app/layout-46965708893096b1.js"],""]
3:T1a75,
인증방식에는 대표적으로 두가지가 있다.

제일 많이 사용하는 세션 방식과 토큰 방식

- 인증 -> 유저가 누구인지 확인
- 인가 -> 유저의 요청에 대한 권한을 확인하고 허가

---

### 세션방식
- 로그인 요청 -> 서버에서 세션 key-value로 구분해 정보를 저장
- 서버 -> 클라이언트 측으로 http header cookie에 세션 id를 담아 전달
- 클라이언트 쪽에서 response값으로 cookie에 저장된 세션을 확인할 수 있는데, 브라우저에 저장

세션 방식은 HTTP요청이 노출되어도 세션 자체에는 의미있는 값이 없기 때문에 보안상 유리할 수 있다.

각 사용자마다 고유한 id를 갖고 있기 때문에 매번 회원정보를 확인할 필요가 없다.

서버에 따로 세션 저장소를 두기 때문에 사용자가 많아지면 서버에 부담이 간다.

각 브라우저들은 보안상의 이슈로 서버와 프론트간의 도메인이 같아야 쿠키가 전달된다.

- 프론트 측에서는 Axios 사용시 ```withCredentials: true```설정을 통해 서로 다른 도메인간의 요청에도 credential 정보를 받을 것인지 설정해야 한다.

- 서버 측에서는 응답 헤더의 Access-Control-Allow-Credentials 항목을 true로 설정해야 하고,
응답 헤더의 Access-Control-Allow-Origin의 값을 와일드 카드('*') 제외하고 설정 되어야 한다.

---

우선 localhost와 서버상의 도메인이 달라 proxy 설정을 해줬다.

```ts
// pages/api/[...path].ts
import type { NextApiRequest, NextApiResponse } from "next";
import httpProxyMiddleware from "next-http-proxy-middleware";

export const config = {
  api: {
    externalResolver: true
  },
}

export default (req: NextApiRequest, res: NextApiResponse) => {
    httpProxyMiddleware(req, res, {
        target: process.env.NEXT_PUBLIC_API_URL,
        changeOrigin: true,
        pathRewrite: [
          {
            patternStr: "^/api/",
            replaceStr: "/",
          },
        ],
        cookieDomainRewrite: {
          "*": "localhost",
        },
      })
    };
```

```ts
/** @type {import('next').NextConfig} */
const nextConfig = {
  swcMinify: true,
  reactStrictMode: true,
  compiler: {
    styledComponents: true,
    removeConsole: process.env.NODE_ENV === "production",
  },
  async rewrites() {
    return process.env.NODE_ENV === "production"
      ? [
          {
            source: "/api/:path*",
            destination: `${process.env.NEXT_PUBLIC_API_URL}/:path*`,
          },
        ]
      : [];
  },
{...}
};
```
---
위 처럼 설정해 주니 서버에서 보낸 cookie가 localhost 브라우저에 잘 들어왔다.

여기서 고민했던 부분이 csr환경이 아닌 next의 ssr환경인 프론트측 서버단에서는 유저인증을 어떻게 확인할 것인가 였다.

우선 로그인 상태와 비로그인 상태에서 접근불가능한 페이지 접근시 리다이렉트를 시키는 방법으로 진행했다.

Nextjs middleware는 root폴더에 middleware.ts 파일을 만들어 주면 페이지 라우팅 되기 전에 middleware가 자동으로 실행된다.

Nextjs에서 지원하는 middleware는 들어오는 요청에 따라서 req, res, header를 다시 작성하거나 리디렉션 등을 수정하거나 재작성할 수 있다.
```ts
import type { NextRequest } from "next/server";
import { fetchAuth, inValidateAuth, validateAuth } from "@/lib/validateUser";

const validatedUrl = [
  "/users/sign-in",
  "/users/sign-up/normal",
  "/users/sign-up/social",
  "/users/sign-up/vendor",
  "/users/password/reset",
];

const inValidateUrl = ["/users/my-page"];

export async function middleware(req: NextRequest) {
  const url = req.nextUrl;

  if (validatedUrl.includes(url.pathname)) {
    return await validateAuth(req);
  }

  if (inValidateUrl.includes(url.pathname)) {
    return await inValidateAuth(req);
  }

  return await fetchAuth(req);
}

export const config = {
  matcher: ["/((?!api|_next/static|_next/image|favicon.ico|assets).*)"],
};
```
```ts
import { NextRequest, NextResponse } from "next/server";

export const validateUser = (req: NextRequest) => {
  return fetch("url", {
    method: "get",
    mode: "cors",
    credentials: "same-origin",
    headers: {
      "Content-Type": "application/json",
      cookie: `${req.headers.get("cookie")}`,
    },
  });
};

{...}

export const fetchAuth = async (req: NextRequest) => {
    try {
        const res = NextResponse.next();

        const response = await validateUser(req);
        const data = await response.json();

        if (response.ok) {
            res.cookies.set("user", JSON.stringify(data));
            return res;
        }

        if (!response.ok) {
            res.cookies.delete("user");
            res.cookies.delete("user.sid");
            return res;
        }
    } catch (e) {
        throw new Error("Validate Error");
    }
};
```

처음에 이런식으로 미들웨어를 구현했다. matcher로 페이지단만 확인했고, 페이지 라우팅시 유저 인증에 성공하면 cookie를 통해 유저정보와 세션을 전달했다.

또 인증성공시 접근 x, 비인증시 접근 x 한 url을 확인해 리다이렉트 시키도록 했다.

처음 해봤던 작업이었고, 제대로 구현한지 확신이 들지 않아 코드리뷰를 요청했다.

middleware를 사용하지 않고 hocs를 사용해 auth를 호출하고, axios config에 headers를 전달하는 방법으로 알려주셨다.

```ts
import React from "react";
import { GetServerSideProps, GetServerSidePropsContext } from "next";
import { getAuth } from "@/models/auth";
import merge from "lodash/merge";

const validatedUrl = [
  "/users/sign-in",
  "/users/sign-up/normal",
  "/users/sign-up/social",
  "/users/sign-up/vendor",
  "/users/password/reset",
];

const inValidateUrl = [
  "/users/my-page",
  "/users/my-page/profile",
  "/users/my-page/review",
];

export default function withAuth(getServerSideProps?: GetServerSideProps) {
  return async function (context: GetServerSidePropsContext) {
    const url = context.req.url as string;
    let user = null;
    try {
      const res = await getAuth({ headers: context.req.headers });
      user = res.data;
    } catch (e) {}
    if (inValidateUrl.includes(url) && !user) {
      return {
        redirect: {
          permanent: false,
          destination: "/users/sign-in",
        },
      };
    }
    {...}
    const ret = await getServerSideProps?.(context);
    return merge(ret, { props: { user } });
  };
}
```

middleware는 nextjs에서 서버도 같이 구성해 사용하면 좋을거라고 조언을 주셨다.

```ts
// page/*
{...}

export const getServerSideProps = withAuth();

{...}
```
4:Tdf0,
예전에 하다가 중단된 프로젝트를 다시 시작해 보려고 새 레포로 마이그레이션 하는 과정에서

패키지 버전도 올리고, 다른 기술을 찾아보다가 예전부터 써보고싶었던 tailwindcss를 써보기로 했다.

```shell
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
```
테일윈드 설치 init을 하게 되면 `postcss.config.js` 파일과 `tailwind.config.js` 파일이 생성된다


```js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./app/**/*.{js,ts,jsx,tsx}",
    "./pages/**/*.{js,ts,jsx,tsx}",
    "./components/**/*.{js,ts,jsx,tsx}",

    // Or if using `src` directory:
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
```
나는 src 폴더를 사용하기 때문에 `"./src/**/*.{js,ts,jsx,tsx}"` 경로로 사용


```css
// globals.css
@tailwind base; // 테일윈드의 기본 스타일
@tailwind components; // 모든 클래스 요소
@tailwind utilities; // 유틸리티
```

전역으로 설정

---

구글에서 지원하는 폰트를 사용해 tailwind에 적용

```js
// Layout
const roboto = Roboto({
    subsets: ["latin"],
    weight: ["400", "500", "700"],
    variable: "--font-roboto"
});

const Layout = ({ children }: { children: React.ReactNode }) => {
    return (
        <main className={`max-w-3xl m-auto p-3 text-black-500 ${roboto.className} font-sans`}>
            <Header />
            {children}
        </main>
    );
};

export default Layout;
```

```js
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
    content: ["./src/**/*.{js,ts,jsx,tsx}"],
    theme: {
        extend: {
            colors: {
                primary: {
                    50: "#f4f6fa",
                    100: "#e8edf5",
                    200: "#c6d1e5",
                    300: "#a4b6d5",
                    400: "#5f7fb6",
                    500: "#1b4897",
                    600: "#184188",
                    700: "#143671",
                    800: "#102b5b",
                    900: "#0d234a"
                },
                secondary: {
                    50: "#fefaf5",
                    100: "#fcf5eb",
                    200: "#f9e6cd",
                    300: "#f5d7af",
                    400: "#edb872",
                    500: "#e59a36",
                    600: "#ce8b31",
                    700: "#ac7429",
                    800: "#895c20",
                    900: "#704b1a"
                },
                black: {
                    50: "#f5f5f5",
                    100: "#eaebeb",
                    200: "#cbcccd",
                    300: "#acaeaf",
                    400: "#6d7174",
                    500: "#2f3438",
                    600: "#2a2f32",
                    700: "#23272a",
                    800: "#1c1f22",
                    900: "#17191b"
                },
                white: "#ffffff"
            },
            fontFamily: {
                sans: ["var(--font-roboto)"]
            }
        }
    }
};

```

테일윈드 자체에 기본 색상이 지정된 것도 있었고,

이런식으로 색상도 지정하면 자동으로 적용되는것 같다.

기본색상을 완전히 바꾸려면 `theme.colors`서 설정이 가능하다고 한다.

---

- 조건부는 템플릿 리터럴을 사용

- 반응형
```js
<img class="w-16 md:w-32 lg:w-48" src="...">
```

- hover나 focus 등
```js
<button class="dark:md:hover:bg-fuchsia-600 ...">
  Save changes
</button>
```
5:T7a1,
자바스크립트의 함수는 호출될 때, 매개변수 이외에 `arguments` 객체와 `this`를 암묵적으로 전달 받는다.

- Java의 `this` 는 인스턴스 자신을 가르키는 참조변수
- this가 객체 자신에 대한 참조 값을 가지고 있다.

하지만 자바스크립트의 `this` 는 함수 호출 방식에 따라 `this` 에 바인딩 되는 객체가 달라진다

---

### 일반 함수 호출

<img src="/assets/blog/javaScript/this-1.png" width="100%" alt="post image"/>

- this → 전역 (window) 객체에 바인딩 됨
- 기본적으로 `this` 는 전역객체에 바인딩 되고, 내부 함수의 경우에도 전역객체에 바인딩 됨

<img src="/assets/blog/javaScript/this-2.png" width="100%" alt="post image"/>

- **내부함수는 일반 함수, 메소드, 콜백함수 어디에서 선언되었든 관게없이 this는 전역객체를 바인딩한다.**

---

### 객체 메소드 호출

<img src="/assets/blog/javaScript/this-3.png" width="100%" alt="post image"/>

- 해당 메소드의 객체에 바인딩 됨

<img src="/assets/blog/javaScript/this-4.png" width="100%" alt="post image"/>

- 프로토타입 객체도 메소드를 가질 수 있다.

프로토 타입 방식이란 자바스크립트에서 객체를 상속하기 위해 사용된다 (템플릿 같은 것)

---

### 생성자 함수 호출

- 생성자 함수란 객체를 생성하는 역할을 함
- **기존 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작**

<img src="/assets/blog/javaScript/this-5.png" width="100%" alt="post image"/>

1. 빈 객체 생성 및 this 바인딩 → 2. this를 통한 프로퍼티 생성 → 3. 생성된 객체 반환

---

### apply/call/bind 호출

- this 객체에 명시적으로 바인딩 하는 방법

---

일반 함수

- 일반 함수 → 화살표 함수
- 생성자 함수 → class
- 객체 메서드 → 객체 메서드 축약형
6:T1aed,
```shell
npm create svelte@latest my-app
cd my-app
npm install
npm run dev
```

SSG 정적 페이지를 구성하는 어댑터
```shell
npm i -D @sveltejs/adapter-static
```
---
svelte.config.js
```js
import adapter from '@sveltejs/adapter-static';

export default {
  kit: {
    adapter: adapter()
  }
};
```
---
src/routes/+layout.js
```js
// This can be false if you're using a fallback (i.e. SPA mode)
export const prerender = true;
```
---

### 레이아웃 구성

```js
<script>
	import Header from '$lib/components/Layout/Header.svelte';
	import Footer from '$lib/components/Layout/Footer.svelte';

	export let data;
</script>

<Header />
    <main>
		<slot />
    </main>
<Footer />
```
slot에 스벨트 페이지들이 렌더되게 된다.

스벨트킷은 넥스트와 비슷하게 routes에서 라우팅이 된다.

---

### 데이터 가져오기

src/routes/+page.svelte
```js
<script>
	import Pagination from '$lib/components/Posts/Pagination.svelte';
	import '$lib/styles/_main.scss';
	import PostList from '$lib/components/Posts/PostList.svelte';
	import Category from '$lib/components/Posts/Category.svelte';
	import { MetaTags } from 'svelte-meta-tags';
	import { seoMeta, seoOg } from '$lib/config';
	export let data;
</script>

<MetaTags {...seoMeta} openGraph={{ ...seoOg }} />

<h1>Blog</h1>

<Category categories={data.categories} />

<PostList posts={data} />

<Pagination currentPage={1} totalPosts={data.total} />

```
+page.js는 페이지와 연결된 로드 함수이며, 데이터를 로드한 다음 페이지가 로드된 데이터를 넘겨 받아 렌더링한다.
SSR, CSR 모두 렌더링 할 수 있다.

+page.server.js 는 항상 서버측에서 로드가 실행된다.

또 src/routes/api 는 독립적인 API 경로이며 페이지와 연결되지 않는다.

src/routes/+page.server.js
```js
import { postsPerPage } from '$lib/config';
import fetchPosts from '$lib/utils/fetchPosts';

export const load = async ({ fetch }) => {
	const options = {
		limit: postsPerPage
	};
	const { posts } = await fetchPosts(options);

	return { posts, total, categories };
};

```

src/routes/api 에서 만든 fetchPosts 함수를 사용해

페이지 진입시 5개의 포스트를 먼저 가져왔다.

---

src/lib/_posts에 각 게시글인 마크다운 파일들을 만들었다.
```js
import { postsPerPage } from '$lib/config';

const fetchPosts = async () => {
	const posts = await Promise.all(
		Object.entries(import.meta.glob('/src/lib/_posts/**/*.md')).map(async ([path, resolver]) => {
			const { metadata } = await resolver();
			const slug = path.split('/').pop()?.slice(0, -3);
			return { ...metadata, slug };
		})
	);

	sortedPosts = sortedPosts.map((post) => ({
		slug: post.slug,
		title: post.title,
		description: post.description,
		category: post.category,
		titleImage: post.titleImage,
		date: new Intl.DateTimeFormat('ko-KR').format(new Date(post.date))
	}));

	return {
		posts: sortedPosts
	};
};

export default fetchPosts;
```

마크다운 파일들을 가져오는 함수

```markdown
---
title: 스벨트킷으로 블로그 만들기
date: 2023-01-30
description: 스벨트킷으로 블로그 만든 과정을 정리
category: javaScript
titleImage: /postIcon/svelte-icon.webp
---
```


위에 작성된 title, date, description... 들이 metadata가 된다.

---

```js
import { error } from '@sveltejs/kit';

export const load = async ({ params }) => {
	try {
		const post = await import(`../../../../lib/_posts/${params.category}/${params.post}.md`);

		return {
			PostContent: post.default.render().html,
			meta: {
				...post.metadata,
				date: new Intl.DateTimeFormat('ko-KR').format(new Date(post.metadata.date)),
				slug: params.post
			}
		};
	} catch (err) {
		throw error(404, err);
	}
};

```
src/routes/blog/[category]/[post] 진입시 load 함수의 context.params를 통해 해당 게시글을 가져온다.

---

### sitemap, rss 만들기

src/sitemap.xml/+server.ts

```js
import fetchPosts from '$lib/utils/fetchPosts';

export const prerender = true;

export const GET = async () => {
	const { posts } = await fetchPosts({ limit: -1 });
	const links = posts.map(
		(p) => `
    <url>
      <loc>https://wonbeenna.github.io/blog/${p.category}/${p.slug}</loc>
      <lastmod>${new Date(p.date).toISOString()}</lastmod>
      <priority>1.0</priority>
    </url>
  `
	);
	const xml = `
    <?xml version="1.0" encoding="UTF-8"?>
    <urlset
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd"
      xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"
      xmlns:image="http://www.google.com/schemas/sitemap-image/1.1"
      xmlns:video="http://www.google.com/schemas/sitemap-video/1.1"
      xmlns:news="http://www.google.com/schemas/sitemap-news/0.9"
      xmlns:mobile="http://www.google.com/schemas/sitemap-mobile/1.0"
      xmlns:pagemap="http://www.google.com/schemas/sitemap-pagemap/1.0"
      xmlns:xhtml="http://www.w3.org/1999/xhtml"
    >
        <url>
            <loc>https://wonbeenna.github.io/</loc>
            <priority>1.0</priority>
        </url>

        <url>
            <loc>https://wonbeenna.github.io/about</loc>
            <priority>1.0</priority>
        </url>

    ${links.join('')}
    </urlset>
  `.trim();
	return new Response(xml, { headers: { 'Content-Type': 'text/xml; charset=utf-8' } });
};
```

GET 메소드를 사용해 서버에서 빌드시 sitemap.xml을 생성

rss도 위와 동일하다.

---

### 마치며

최근에 스벨트를 공부해보는 기회가있어, 스벨트킷을 사용해 간단한 블로그를 만들어 봤다.

아직 깊게 사용해보진 못했지만, 먼저 리액트와 비교했을 때 코드량이 많이 줄어든 느낌이다.

- 프레임워크는 코드량이 적을 수록 속도가 빠르다고 들었다.

- 순수한 native가 가장 좋다.

- 아무리 좋은 프레임워크라도 vanilla js를 따라갈 수는 없다.

그런 면에서 virtual DOM을 사용하지 않는 스벨트가 가장 빠를 것이다. 하지만 최적화는 개발자의 몫..

- 스벨트는 런타임이 아닌 컴파일러에 가깝기 때문에 실제 실행 가능한 vanilla js를 만들어 준다.

리액트였으면 useState니 뭐니~ 상태 관리니~ 했을 것 같은데 스벨트는 변수 하나만 선언하면 가능했다.

- 리액트에 hook, jsx, context, use함수 등 규칙들이 필요없었고, 오로지 html, css, js로 개발할 수 있다.

요즘 많이 핫하고 뜨는 프레임워크라고 해서 정보들이 많을줄 알았는데 생각보다 더 정보가 없었다.

구글링을 해도 스벨트 관련된 정보들이 많진 않았다. 거의 공식블로그를 많이 참고했다.

그래도 앞으론 리액트를 더 공부 할 것이다. 먹고 살려면 ㅎㅎ

7:T9de,

얼마전 해외 블로그를 구경하다가 이런 글을 보았다.

-   리액트 조건부 렌더링에서 생각없이 && 연산자를 사용하지 말아라
-   무조건 && 연산자를 사용하면 버그가 발생할 수 있다?

이 글을 보면서 올바르게 사용하는 방법과,

어떤식으로 사용하면 버그가 발생할 수 있는지 생각해 보는 계기가 되었다.

우선 && 연산자는 논리 연산자로 예를 들면 다음과 같이 동작한다

```javascript
const a = 3;
const b = -2;

console.log(a && b);
// expected output: -2
```

왼쪽에서 오른쪽으로 값을 평가하고 true인 경우 오른쪽으로 false인 경우 평가대상이된 피연산자를 반환한다.

```javascript
function Component({ condition }) {

  return (
    <div>
      {condition && <OtherComponent />}
     </div>
  );
}
```

Or

```javascript
function Component({ condition }) {

  return (
    <div>
      {condition ? <OtherComponent /> : null}
     </div>
  );
}
```

[리액트 공식문서](https://reactjs.org/docs/conditional-rendering.html)에는 && 연산자를 쓰는데 유용할 수 있다고 설명하고 있으며,

보통 삼항 연산자는 코드의 가독성 때문에 잘 사용하지 않고, 또 세개의 항이 없는 경우에도 사용하지 않는다.

위 같은 경우 문제될 수 있는 상황이 있는데, 

```javascript
function Component() {
  const count = 0;

  return (
    <div>
      {count && <h1>{count}</h1>}
     </div>
  );
}
```

js의 falsy값을 평가 할때이다.

[https://developer.mozilla.org/ko/docs/Glossary/Falsy](https://developer.mozilla.org/ko/docs/Glossary/Falsy)

count = 0 은 **false**로 평가되고, && 연산자를 사용하기 때문에 0을 반환하게 되므로 내가 생각한 의도대로 동작하지 않을것이다.

```javascript
<div>0</div>
```

이런 경우 count 를 Boolean으로 평가하게 하면 의도한대로 동작하게 된다. 

```javascript
function Component() {
  const count = 0;

  return (
    <div>
      {!!count && <h1>{count}</h1>}
     </div>
  );
}
```

따라서, 무조건 && 연산자를 피하는것 보다는 평가 대상이 되는 값을 생각해보며 사용하는게 좋을 것 같다.

실제 개발하면서

Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.

이런 에러를 만난 적이 많았는데, 위와 관련된 것이 아닌가 생각 된다.

조금 더 생각하면서 개발하자
8:Tff5,
예전부터 궁금했었던 부분이었다.

**useCallback**과 **useMemo** hook은 함수와 값을 메모이제이션 해주는 역할을 한다.

그렇다면 **무조건 쓰기만하면** 성능상 이점을 가져갈 수 있을까?

리액트는 아래 세가지인 경우 렌더링을 발생시킨다.

**\- state 변경이 있을 때**

**\- props 변경이 있을 때**

**\- 부모 컴포넌트가 업데이트 될 때 모든 자식 컴포넌트**

이때 불필요한 렌더링을 막기위해 useCallback과 useMemo를 사용하지만, 최적화에는 항상 비용이 따른다.

---

```javascript
import {useState} from "react";
import Count from "./Count";

function App() {
    const [count, setCount] = useState(1);

    const handleClick = () => {
        setCount(prevCount => prevCount + 1)
    }

    return (
        <div>
            <h1>{count}</h1>
            <div>
                <Count onClick={handleClick} />
            </div>
        </div>
    );
}

export default App;
```

위와 같은 코드에서 App에 state가 변경되기 때문에 Count도 렌더링 될것이다.

<img src="/assets/blog/javaScript/use.gif" width="100%" alt="post image"/>

부모컴포넌트의 state가 변경되었고,

handleClick() 함수의 참조 동일성이 일치하지 않아 리렌더링 되고있다.

```javascript
import React from 'react';

function Count(props) {
    console.log('CountRender')
    return (
        <div>
            <button onClick={props.onClick}>Click</button>
        </div>
    );
}

export default React.memo(Count);
```

자식 컴포넌트에 React.memo로 감싸주면 props를 비교할 것이다.

이때 props onClick은 App에서 메모이제이션이 되지않아 여전히 리렌더링이 발생한다.

```javascript
const handleClick = useCallback(() => {
    setCount(prevCount => prevCount + 1)
}, [])
```

useCallback으로 감싸주면 handleClick은 메모이제이션되어 새로 생성되지않고, props로 전달되기 때문에 리렌더링이 발생하지 않는다.

<img src="/assets/blog/javaScript/use(1).gif" width="100%" alt="post image"/>

---

리액트에서 이야기하는 useMemo는 매렌더링마다 고비용 연산을 피하기 위해 사용한다고 하지만, 고비용에 대한 이야기에 대해서는 자세하게 나와있지 않다.

리액트에서 이야기하는 고비용 연산은 하위 렌더트리들을 렌더링하는 연산을 이야기 하는 것이고, 이러한 경우가 아니라면 거의 대부분 useMemo를 사용하지 않아도 된다.

---

```javascript
const Component = () => {

  const fetch = useCallback(() => {
    console.log('fetch');
  }, []);

  useEffect(() => {
    fetch();
  }, [fetch]);

  {...}
};
```

useMemo와 useCallback은 초기 렌더링에는 쓸모가 없다. 오히려 초기 렌더링에 useMemo와 useCallback이 값을 저장하는 행위는 오히려 성능을 저하시킬 수 있다는 것을 생각하자.

위와같은 코드에서 fetch가 변경되어야 useCallback을 사용하는 것이 의미가 있다.

---

앱이 점점 커지고 모든 값이나 함수에 useMemo와 useCallback을 사용한다면 오히려 앱이 느려지는 원인이 될 수 있다.

[https://ko.reactjs.org/docs/optimizing-performance.html#avoid-reconciliation](https://ko.reactjs.org/docs/optimizing-performance.html#avoid-reconciliation)

단순한 값이나 함수를 메모이제이션 하는것 보다는 앱 설계 단계부터 리렌더링이 발생할 수 있는 부분을 생각하고, 리렌더링이 발생하는 특정 부분에서만 메모이제이션을 사용하는게 앱을 최적화 하는데 더 좋을 것이다.

단순한 값이나 함수를 메모이제이션 하는건 오히려 더 느려질 뿐만 아니라, 성능에 미미하게 영향을 끼칠것이다.

참고:

[https://beta.reactjs.org/reference/react/useMemo#usage](https://beta.reactjs.org/reference/react/useMemo#usage)

[https://www.developerway.com/posts/how-to-use-memo-use-callback](https://www.developerway.com/posts/how-to-use-memo-use-callback)
9:T84a,
### fireEvent를 userEvent로 바꿔보기

```shell
npm i @testing-library/user-event
```

```js
test('Checkbox enables button on first click and disableds on second click', async () => {
  const user = userEvent.setup();

  render(<SummaryForm />);

  const checkbox = screen.getByRole('checkbox', {
    name: /terms and conditions/i
  });
  const confirmButton = screen.getByRole('button', {
    name: /confirm order/i
  });

  await user.click(checkbox);
  expect(confirmButton).toBeEnabled();

  await user.click(checkbox);
  expect(confirmButton).toBeDisabled();
});
```

async/await 으로 비동기 처리해주지 않으면, expect가 먼저 실행되기 때문에 오류가 발생한다

---

### Screen 메소드들 써보기

```js
test('popover responds to hover', async () => {
  const user = userEvent.setup();

  render(<SummaryForm />);

  // popover starts out hidden
  const nullPopover = screen.queryByText(/no ice cream will actually be delivered/i);
  expect(nullPopover).not.toBeInTheDocument();

  // popover appears on mouseover of checkbox label
  const termsAndConditions = screen.getByText(/terms and conditions/i);
  await user.hover(termsAndConditions);
  const popover = screen.getByText(/no ice cream will actually be delivered/i);
  expect(popover).toBeInTheDocument();

  // popover disappears when we mouse out
  await user.unhover(termsAndConditions);
  expect(popover).not.toBeInTheDocument();
});
```

- get : 요소 조회시 나타날 것으로 예상되는 경우 -> 일치하는 요소가 없으면 Error를 반환

- query : 요소가 존재하는지 확인하는 경우 -> 일치하는 요소가 없으면 null을 반환

- find : 요소가 비동기적으로 표시될 수 있는 경우인지

```js
const popover = (
  <Popover id="popover-basic">
    <Popover.Body>No ice cream will actually be delivered</Popover.Body>
  </Popover>
);

const checkboxLabel = (
  <span>
    I agree to
    <OverlayTrigger trigger={['hover', 'focus']} placement="right" overlay={popover}>
      <span style={{color: 'blue'}}>Terms and Conditions</span>
    </OverlayTrigger>
  </span>
);
```
a:Tff3,
### * Mock Service Worker

백엔드에서 데이터를 가져오는 부분을 테스트

- MSW 작동 방식

브라우저에 서비스 워커를 등록해 외부로 나가는 네트워크 리퀘스트를 감지

요청을 실제 서버로 갈 때 중간에 가로채 MSW 클라이언트 사이드 라이브러리로 보내고, 등록된 핸들러에서 요청을 처리한 후 모의 응답을 보낸다.

---

### * jest를 사용한 node와 통합하기

```shell
npm install msw --save
```

- 핸들러 생성하기

```js
import {rest} from 'msw';

export const handlers = [
  rest.get('http://localhost:5000/products', (req, res, ctx) => {
    return res(
      ctx.json([
        {
          name: 'America',
          imagePath: '/images/america.jpeg'
        },
        {
          name: 'England',
          imagePath: '/images/england.jpeg'
        }
      ])
    );
  }),
  rest.get('http://localhost:5000/options', (req, res, ctx) => {
    return res(
      ctx.json([
        {
          name: 'Insurance'
        },
        {
          name: 'Dinner'
        }
      ])
    );
  })
];
```

- mocking 서버 생성하기

```js
import {setupServer} from 'msw/node';
import {handlers} from './handlers';

export const server = setupServer(...handlers);
```

- setupTest.js에 서버 생성

```js
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

import {server} from './mocks/server';

beforeAll(() => server.listen()); // 테스트 시작 전에 서버 listen
afterEach(() => server.resetHandlers()); // 테스트 중 다른 테스트에 영향이 가지 않도록
afterAll(() => server.close()); // 테스트 후 서버를 클린업
```

- 테스트 코드 작성

```js
import {server} from '../../../mocks/server';
import Type from '../Type';
import {rest} from 'msw';
import {render, screen} from '@testing-library/react';

test('displays product images from server', async () => {
  render(<Type orderType="products" />);

  // 서버에서 받아온 이미지
  const productImages = await screen.findAllByRole('img', {
    name: /product$/i
  });
  expect(productImages).toHaveLength(2);

  const altText = productImages.map((element) => element.alt);
  expect(altText).toEqual(['America product', 'England product']);
});

test('fetch option information from server', async () => {
  render(<Type orderType="options" />);

  const optionCheckboxes = await screen.findAllByRole('checkbox');

  expect(optionCheckboxes).toHaveLength(2);
});

test('when fetching product datas, face an error', async () => {
  // 서버에 대한 에러 확인
  server.resetHandlers(
    rest.get('http://localhost:5000/products', (req, res, ctx) => {
      return res(ctx.status(500));
    })
  );

  render(<Type orderType="products" />);

  const errorBanner = await screen.findByTestId('error-banner');
  expect(errorBanner).toHaveTextContent('에러가 발생했습니다.');
});
```

- 컴포넌트

```js
import React, {useEffect, useState} from 'react';
import axios from 'axios';
import Products from './Products';
import ErrorBanner from '../../components/ErrorBanner';
import Options from './Options';

const Type = ({orderType}) => {
  const [items, setItems] = useState([]);
  const [error, setError] = useState(false);

  useEffect(() => {
    loadItems(orderType);
  }, [orderType]);

  const loadItems = async (orderType) => {
    try {
      const response = await axios.get(`http://localhost:5000/${orderType}`);
      setItems(response.data);
    } catch (error) {
      setError(true);
    }
  };

  const ItemComponents = orderType === 'products' ? Products : Options;

  const optionItems = items.map((item) => {
    return <ItemComponents key={item.name} name={item.name} imagePath={item.imagePath} />;
  });

  if (error) {
    return <ErrorBanner message="에러가 발생했습니다." />;
  }

  return <div>{optionItems}</div>;
};

export default Type;
```
b:T1633,
### * Jest - Facebook에서 만든 테스팅 프레임 워크.

주로 단위 (unit) 테스트를 위해 사용.

- filename.test.js

- filename.spec.js

All files inside "tests" folders

- describe -> 테스트를 그룹화 하는데 사용

- test(it) - 개별 테스트를 수행

- test(it) - 개별 테스트를 수행

- test(it) - 개별 테스트를 수행

- expect 함수는 값을 테스트할 때마다 사용, matcher(다른 방법으로 값을 테스트)와 함께 사용

---

### 시작해보기

cra 폴더로 가서

```shell
npm test
```

파일명에 test가 들어간 파일을 찾는다.

a로 App.test.js에 있는 모든 테스트를 실행

```js
test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});
```

- render함수는 DOM에 컴포넌트를 랜더링 하는 함수, return은 RTL(리액트 테스트 라이브러리)에 쿼리 함수와 기타 유틸리티를 담고 있는 객체를 리턴한다.

```js
test('renders learn react link', () => {
  const { getByText } = render(<App />);
  const linkElement = getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});
```

아래 처럼도 쓸수 있다. (쿼리함수를 직접 쓰는 경우는 거의 없고 screen 객체로 이용)

```js
<a
  className="App-link"
  href="https://reactjs.org"
  target="_blank"
  rel="noopener noreferrer"
>
  Learn React
</a>
```

linkElement가 Document안에 있는지 판단하는 matcher

---

### 쿼리함수

쿼리는 페이지에서 요소를 찾기 위해 테스트 라이브러리가 제공하는 방법

- getBy~: 쿼리에 대해 일치하는 노드를 반환, 일치하는 요소가 없거나 둘 이상의 일치가 발견되면 에러를 반환(둘 이상의 요소는 getAllBy~ 사용)

- queryBy~: 쿼리에 대해 일치하는 노드 반환, 일치하는 요소가 없으면 null을 반환

- findBy~: (getBy + waitFor)주어진 쿼리와 일치하는 요소가 발견되면 Promise를 반환 (둘 이상의 요소는 findAllBy~ 사용)

- waitFor: 일정 기간 동안 기다리도록

---

### 린트

```
"eslint-plugin-jest-dom"
"eslint-plugin-testing-library"
```

---

### TDD(Test Driven Development)

실제 코드를 작성하기 전에 테스트 코드를 먼저 작성

### 간단한 카운팅 앱 만들어보기

```js
test('Counter starts at 0', () => {
  render(<App />);
  // screen object로 원하는 엘리멘트에 접근(ID)
  const counterElement = screen.getByTestId('counter');
  // id가 counter인 엘리멘트의 텍스트가 0인가?
  expect(counterElement).toHaveTextContent(0);
});
```

```js
import './App.css';
import {useState} from 'react';

function App() {
  const [count, setCount] = useState(0);

  return (
    <div className="App">
      <header className="App-header">
        <h3 data-testid="counter">{count}</h3>
      </header>
    </div>
  );
}

export default App;
```

- 버튼 추가하기

```js
test('Minus Button', () => {
  render(<App />);
  const buttonElement = screen.getByTestId('minus-button');
  expect(buttonElement).toHaveTextContent('-');
});

test('Plus Button', () => {
  render(<App />);
  const buttonElement = screen.getByTestId('plus-button');
  expect(buttonElement).toHaveTextContent('+');
});
```

```js
<div>
  <button data-testid="minus-button">-</button>
  <button data-testid="plus-button">+</button>
</div>
```

### FireEvent API

유저가 발생시키는 액션(이벤트)에 대한 테스트

- 버튼 이벤트 추가하기

```js
test('When the + button is pressed, the counter change to 1', () => {
  render(<App />);
  const buttonElement = screen.getByTestId('plus-button');
  // 버튼 클릭
  fireEvent.click(buttonElement);
  // plus 버튼 클릭시 counter 엘리먼트는 1
  const counterElement = screen.getByTestId('counter');
  expect(counterElement).toHaveTextContent(1);
});

test('When the - button is pressed, the counter change to -1', () => {
  render(<App />);
  const buttonElement = screen.getByTestId('minus-button');
  // 버튼 클릭
  fireEvent.click(buttonElement);
  // minus 버튼 클릭시 counter 엘리먼트는 -1
  const counterElement = screen.getByTestId('counter');
  expect(counterElement).toHaveTextContent(-1);
});
```

```js
const [count, setCount] = useState(0);

const handlePlus = () => {
  setCount((prevState) => prevState + 1);
};

const handleMinus = () => {
  setCount((prevState) => prevState - 1);
};

return (
  <div className="App">
    <header className="App-header">
      <h3 data-testid="counter">{count}</h3>
      <div>
        <button data-testid="minus-button" onClick={handleMinus}>
          -
        </button>
        <button data-testid="plus-button" onClick={handlePlus}>
          +
        </button>
      </div>
    </header>
  </div>
);
```

- on/off 버튼 색상과 클릭시 -, +버튼 disabled

```js

test('on/off button has blue color', () => {
  render(<App />);
  const buttonElement = screen.getByTestId('on/off-button');
  expect(buttonElement).toHaveStyle({backgroundColor: 'blue'});
});

test('Prevent -,+ button from being pressed when the on/off button is clicked', () => {
  render(<App />);
  const onOffButtonElement = screen.getByTestId('on/off-button');
  fireEvent.click(onOffButtonElement);
  const plusButtonElement = screen.getByTestId('plus-button');
  const minusButtonElement = screen.getByTestId('minus-button');
  expect(plusButtonElement).toBeDisabled();
  expect(minusButtonElement).toBeDisabled();
});
```

```js
<button data-testid="on/off-button" style={{backgroundColor: 'blue'}} onClick={handleDisabled}>
  on/off
</button>
```
e:["page","2","d"]
0:["PK0fMI_0NqJ4X2ENb6twX",[[["",{"children":["page",{"children":[["page","2","d"],{"children":["__PAGE__?{\"page\":\"2\"}",{}]}]}]},"$undefined","$undefined",true],["",{"children":["page",{"children":[["page","2","d"],{"children":["__PAGE__",{},["$L1",["$","section",null,{"className":"flex flex-col-reverse md:relative md:flex-row","children":[["$","$L2",null,{"posts":{"posts":[{"content":"$3","data":{"title":"Next.js middleware와 getServerSideProps","date":"$D2023-02-22T00:00:00.000Z","description":"세션방식의 로그인 인증, middleware와 getServerSideProps를 사용해 구현한 기록","category":"javaScript","titleImage":"/assets/postIcon/Nextjs.svg"},"slug":"next-middleware"},{"content":"$4","data":{"title":"Nextjs에서 tailwind 써보기","date":"$D2023-02-18T00:00:00.000Z","description":"공식문서 보면서 tailwind 써보기","category":"javaScript","titleImage":"/assets/postIcon/tailwind-css-icon.png"},"slug":"tailwindcss"},{"content":"$5","data":{"title":"JavaScript this","date":"$D2023-02-02T00:00:00.000Z","description":"사내 스터디 this","category":"study","titleImage":"/assets/postIcon/javascript.png"},"slug":"this"},{"content":"$6","data":{"title":"스벨트킷으로 블로그 만들어보기","date":"$D2023-01-30T00:00:00.000Z","description":"스벨트킷으로 블로그 만든 과정을 정리","category":"javaScript","titleImage":"/assets/postIcon/svelte-icon.webp"},"slug":"svelte-blog"},{"content":"\n### Provider 테스팅 해보기\n\n```js\nrender(<Options optionType=\"scoops\" />, {wrapper: OrderDetailsProvider});\n```\n\n테스트 wrapper에 Provider로 감싸주면 된다.\n\n여기서는 redux나 recoil 등 다른 라이브러리도 가능\n\n---\n\n전역적으로도 사용이 가능\n\n```js\nimport {render} from '@testing-library/react';\nimport {OrderDetailsProvider} from '../contexts/OrderDetails';\n\nconst renderWithContext = (ui, options) => render(ui, {wrapper: OrderDetailsProvider, ...options});\n\nexport * from '@testing-library/react';\n\nexport {renderWithContext as render};\n```\n","data":{"title":"리액트 테스팅(4)","date":"$D2023-01-02T00:00:00.000Z","description":"jest와 react-testing-library","category":"javaScript","titleImage":"/assets/postIcon/test.png"},"slug":"react-testing-4"},{"content":"$7","data":{"title":"리액트 조건부 렌더링에 대한 생각","date":"$D2022-12-29T00:00:00.000Z","description":"해외 블로그를 보며 정리한 조건부 렌더링에 대한 생각","category":"javaScript","titleImage":"/assets/postIcon/logo192.png"},"slug":"conditional-rendering"},{"content":"$8","data":{"title":"useCallback, useMemo 무조건 좋은가?","date":"$D2022-12-28T00:00:00.000Z","description":"useCallback과 useMemo에 대한 생각 정리","category":"javaScript","titleImage":"/assets/postIcon/logo192.png"},"slug":"usecallback-and-usememo"},{"content":"$9","data":{"title":"리액트 테스팅(3)","date":"$D2022-12-26T00:00:00.000Z","description":"jest와 react-testing-library","category":"javaScript","titleImage":"/assets/postIcon/test.png"},"slug":"react-testing-3"},{"content":"$a","data":{"title":"리액트 테스팅(2)","date":"$D2022-12-14T00:00:00.000Z","description":"jest와 react-testing-library","category":"javaScript","titleImage":"/assets/postIcon/test.png"},"slug":"react-testing-2"},{"content":"$b","data":{"title":"리액트 테스팅(1)","date":"$D2022-12-10T00:00:00.000Z","description":"jest와 react-testing-library","category":"javaScript","titleImage":"/assets/postIcon/test.png"},"slug":"react-testing-1"}],"total":34},"page":"2","category":"$undefined"}],["$","ul",null,{"className":"relative top-0 flex h-fit min-w-fit flex-row flex-wrap gap-[20px] py-[20px] pl-0 md:sticky md:top-[100px] md:flex-col md:flex-nowrap md:py-0 md:pl-[30px]","children":[["$","h2",null,{"className":"hidden text-[18px] font-bold md:inline","children":"Category"}],[["$","li","javaScript",{"children":["$","$Lc",null,{"className":"text-gray700","href":"/blog/javaScript","children":"javaScript (31)"}]}],["$","li","study",{"children":["$","$Lc",null,{"className":"text-gray700","href":"/blog/study","children":"study (2)"}]}],["$","li","til",{"children":["$","$Lc",null,{"className":"text-gray700","href":"/blog/til","children":"til (1)"}]}]]]}]]}],null]]},["$","$Ld",null,{"parallelRouterKey":"children","segmentPath":["children","page","children","$e","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$Lf",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},["$","$Ld",null,{"parallelRouterKey":"children","segmentPath":["children","page","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$Lf",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},[null,["$","html",null,{"lang":"ko","suppressHydrationWarning":true,"children":[null,["$","$L10",null,{"src":"https://www.googletagmanager.com/gtag/js?id=G-LFDRQZPCBN"}],["$","$L10",null,{"id":"google-analytics","children":"\n          window.dataLayer = window.dataLayer || [];\n          function gtag(){dataLayer.push(arguments);}\n          gtag('js', new Date());\n \n          gtag('config', 'G-LFDRQZPCBN');\n        "}],["$","body",null,{"suppressHydrationWarning":true,"className":"__className_471caf","children":["$","$L11",null,{"children":[["$","$12",null,{"fallback":null,"children":["$","$L13",null,{"children":["$","$L14",null,{}]}]}],[["$","header",null,{"className":"sticky top-0 z-10 mx-auto my-0 h-[56px] border-b-[1px] border-b-gray200 bg-white px-[24px] py-0 dark:bg-darkBg01","children":["$","section",null,{"className":"m-auto flex h-full max-w-[970px] items-center justify-between","children":[["$","div",null,{"className":"flex items-center gap-[20px]","children":[["$","$Lc",null,{"href":"/","children":["$","$L15",null,{"src":"/assets/icons/been-logo.svg","width":60,"height":56,"alt":"logo"}]}],["$","div",null,{"className":"flex items-center gap-[20px]","children":["$","$Lc",null,{"href":"/about","children":"About"}]}]]}],["$","$12",null,{"fallback":null,"children":["$","$L13",null,{"children":["$","$L16",null,{}]}]}]]}]}],["$","main",null,{"className":"mx-auto my-0 max-w-[970px] p-[16px]","children":["$","$Ld",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$Lf",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":null}]}],["$","footer",null,{"className":"flex items-center justify-center pb-[16px] text-center text-[14px] text-gray600","children":"Copyright © Been."}]]]}]}]]}],null]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/f02a732008014100.css","precedence":"next","crossOrigin":""}]],"$L17"]]]]
17:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Been blog - 2"}],["$","meta","3",{"name":"description","content":"Been dev-note"}],["$","meta","4",{"name":"google-site-verification","content":"BirkRt7C7FYMLW96RbXad2EtPdcl0-_ti9xCRkCHa5U"}],["$","meta","5",{"name":"naver-site-verification","content":"58945b2bbe2fe86252fa8c7b204b40f6019920e9"}],["$","meta","6",{"property":"og:title","content":"Been blog - 2"}],["$","meta","7",{"property":"og:description","content":"Been dev-note - 2"}],["$","meta","8",{"property":"og:url","content":"https://wonbeenna.github.io/page/2"}],["$","meta","9",{"property":"og:site_name","content":"Been blog"}],["$","meta","10",{"property":"og:image","content":"https://wonbeenna.github.io/favicon.png"}],["$","meta","11",{"property":"og:image:width","content":"800"}],["$","meta","12",{"property":"og:image:height","content":"600"}],["$","meta","13",{"property":"og:image:alt","content":"Been blog"}],["$","meta","14",{"property":"og:type","content":"website"}],["$","meta","15",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","16",{"name":"twitter:title","content":"Been blog - 2"}],["$","meta","17",{"name":"twitter:description","content":"Been dev-note - 2"}],["$","meta","18",{"name":"twitter:image","content":"https://wonbeenna.github.io/favicon.png"}],["$","meta","19",{"name":"twitter:image:width","content":"800"}],["$","meta","20",{"name":"twitter:image:height","content":"600"}],["$","meta","21",{"name":"twitter:image:alt","content":"Been blog"}],["$","link","22",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"192x192"}],["$","meta","23",{"name":"next-size-adjust"}]]
1:null
