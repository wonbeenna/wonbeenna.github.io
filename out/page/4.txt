2:I[8451,["438","static/chunks/438-20a73b8af0ca1535.js","411","static/chunks/app/page/%5Bpage%5D/page-10f5b8e52537b5e8.js"],""]
8:I[5250,["438","static/chunks/438-20a73b8af0ca1535.js","411","static/chunks/app/page/%5Bpage%5D/page-10f5b8e52537b5e8.js"],""]
9:I[5613,[],""]
b:I[1778,[],""]
c:I[5935,["438","static/chunks/438-20a73b8af0ca1535.js","185","static/chunks/app/layout-46965708893096b1.js"],""]
d:I[4840,["438","static/chunks/438-20a73b8af0ca1535.js","185","static/chunks/app/layout-46965708893096b1.js"],"Providers"]
e:"$Sreact.suspense"
f:I[6005,["438","static/chunks/438-20a73b8af0ca1535.js","185","static/chunks/app/layout-46965708893096b1.js"],"NoSSR"]
10:I[286,["438","static/chunks/438-20a73b8af0ca1535.js","185","static/chunks/app/layout-46965708893096b1.js"],""]
11:I[1749,["438","static/chunks/438-20a73b8af0ca1535.js","185","static/chunks/app/layout-46965708893096b1.js"],"Image"]
12:I[9137,["438","static/chunks/438-20a73b8af0ca1535.js","185","static/chunks/app/layout-46965708893096b1.js"],""]
3:T1f48,
**[유동균님의 강의](https://www.inflearn.com/course/%EC%9B%B9-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%A6%AC%EC%95%A1%ED%8A%B8-1)를 보며 정리한 글 입니다.**

---

### 1\. 구글 개발자 도구 Audits(LightHouse) 툴을 이용한 페이지 검사

<img src="/assets/blog/javaScript/web-optimization1.png" width="100%" alt="post image"/>
<img src="/assets/blog/javaScript/web-optimization2.png" width="100%" alt="post image"/>

**Opportunities** = 리소스의 관점(로딩성능)

**Diagnostics** = 페이지의 실행 관점(렌더링)

---

### 2\. 이미지 사이즈 최적화 - 로딩 성능

<img src="/assets/blog/javaScript/web-optimization3.png" width="100%" alt="post image"/>

실제 이미지와 렌더링된 이미지의 크기가 다르다

보통 이미지는 x2의 이미지를 사용

api를 통해 받아온 이미지를 조절하려면?

**Image CDN**(image processing Contents Delivery Network) - 이미지 가공 → 소비자

CDN 구축은 진행하지 않았다.

---

### 3\. performance

크롬 개발자도구 -> 성능에서 새로고침을 누르면 페이지의 작업을 분석해준다.

<img src="/assets/blog/javaScript/web-optimization4.png" width="100%" alt="post image"/>
<img src="/assets/blog/javaScript/web-optimization5.png" width="100%" alt="post image"/>

1.  HTML파싱
2.  JS 로드
3.  첫 페인팅 이후 API 호출

- 리액트는 프레임차트에서 각 컴포넌트마다 실행되는 시간이 보여진다.

---

### 4\. Route-based code Splitting

코드 스플릿팅은 webpack, rollup 등과 같은 모듈 번들러를 이용하여 만들어진 하나의 번들 파일을 여러 개의 번들 파일로 나누는 것을 의미한다.

하나의 번들파일을 여러개로 나누면 그만큼 로드 속도가 빨라진다.

```js
import React, {Suspense, lazy} from 'react'
import { Switch, Route } from 'react-router-dom'
import './App.css'
// import ListPage from './pages/ListPage/index'
// import ViewPage from './pages/ViewPage/index'

const ListPage = lazy(() => import('./pages/ListPage/index'))
const ViewPage = lazy(() => import('./pages/ViewPage/index'))

function App() {
  return (
    <div className="App">
        <Suspense fallback={<div>로딩 중...</div>}>
          <Switch>
            <Route path="/" component={ListPage} exact />
            <Route path="/view/:id" component={ViewPage} exact />
          </Switch>
        </Suspense>
    </div>
  )
}

export default App
```

import()를 **lazy**라는 함수 안에 넣고, **Suspense**라는 컴포넌트로 관리를 해줄 수 있다.

데이터가 로딩중에 유저에게 비어있는 컴포넌트가 보이게 되는데, Suspense를 사용해서 이 로딩중인 상태일 때 다른 컴포넌트를 보여줄 수 있다.

Suspense는 fallback을 받아 import하는 도중에 띄어준다.

페이지가 로드될 때 그 페이지 안에서 보이지 않는 컴포넌트가 존재할 수 있는데, 이 부분을 스플리팅해 관리 할 수도 있다.

---

### 5\. 애니메이션 최적화

일반적인 모니터는 초당 60FPS, 브라우저도 초당 60FPS로 화면을 그리게 된다.

여기서 브라우저가 60FPS 아래로 그리게 된다면 쟁크 현상이 발생함.

<img src="/assets/blog/javaScript/web-optimization6.png" width="100%" alt="post image"/>

1. DOM + CSSOM

<img src="/assets/blog/javaScript/web-optimization7.png" width="100%" alt="post image"/>

2. Render Tree

<img src="/assets/blog/javaScript/web-optimization8.png" width="100%" alt="post image"/>

위 DOM과 CSSOM을 조합해 RenderTree를 만들어 낸다.

3. Layout

<img src="/assets/blog/javaScript/web-optimization9.png" width="100%" alt="post image"/>

위치나 크기를 계산해 화면에 레이아웃을 그린다.

4. Paint

이렇게 그려진 레이아웃위에 색을 채워넣음

5. Composite

<img src="/assets/blog/javaScript/web-optimization10.png" width="100%" alt="post image"/>

각 레이어들을 합성하는 과정

이 전체의 과정을 Critical Rendering Path, Pixel Pipeline 이라고 부른다.

이 완성된 상태에서 변화가 생긴다면 처음으로 돌아가 다시 이 전체의 과정을 거치게 된다.

- width, height가 변경되면, **1 -> 2 -> 3 -> 4 -> 5** 모두 실행되게 된다 **(Reflow)**

- 크기나 위치가 아니라 color, background-color(색깔)이 변경됐을땐 **1 -> 2 -> 4 -> 5** **(Repaint)**

- transform, opacity 등(GPU가 관여하는 속성) 변경일 때 **1 -> 2 -> 5**

따라서 transform, opacity 등(GPU가 관여하는 속성)을 사용하는게 가장 빠르고 끊김없이 보여줄 수 있다.

<img src="/assets/blog/javaScript/web-optimization11.png" width="100%" alt="post image"/>

---

### 6\. 컴포넌트 Lazy Loading, Preload

위에서 했던것 처럼 이미지를 보여주는 모달만 따로 스플릿팅 할 수있다.

```js
import React, { useState, Suspense, lazy } from 'react'
import styled from 'styled-components'
import Header from './components/Header'
import InfoTable from './components/InfoTable'
import SurveyChart from './components/SurveyChart'
import Footer from './components/Footer'

const LazyImageModal = lazy(() => import('./components/ImageModal'))

function App() {
    const [showModal, setShowModal] = useState(false)

    return (
        <div className="App">
            <Header />
            <InfoTable />
            <ButtonModal onClick={() => { setShowModal(true) }}>올림픽 사진 보기</ButtonModal>
            <SurveyChart />
            <Footer />
            <Suspense fallback={null}>
                {showModal ? <LazyImageModal closeModal={() => { setShowModal(false) }} /> : null}
            </Suspense>
        </div>
    )
}
```

#### Lazy Loading의 단점

<img src="/assets/blog/javaScript/web-optimization12.png" width="100%" alt="post image"/>

우리가 모달을 클릭한순간 모달에 관련된 파일을 불러오고 JS를 Evaluate한다.

이게 끝나고 실제로 모달을 띄우는 코드가 실행된다.

최초 페이지에서는 성능이 조금 빨라졌지만 모달을 띄울 때는 오히려 성능이 더 느려졌다.

#### **\- 컴포넌트 Preload**

<img src="/assets/blog/javaScript/web-optimization13.png" width="100%" alt="post image"/>

이를 개선하기 위해서 모달을 열기 이전에 모달과 관련된 코드를 미리 로드해 둔다.

문제는 사용자가 모달을 언제 클릭할지 모르기 때문에 언제 미리 로드할지 애매하다.

#### 타이밍

1. 버튼 위에 마우스를 올려 놨을 때

```js
const handleMouseEnter = () => {
    const Component = import('./components/ImageModal')
}
<ButtonModal onClick={() => { setShowModal(true) }} onMouseEnter={handleMouseEnter}>올림픽 사진 보기</ButtonModal>
```

<img src="/assets/blog/javaScript/web-optimization14.png" width="100%" alt="post image"/>

2. 최초 페이지 로드가 되고, 모든 컴포넌트의 마운트가 끝났을 때(ComponentDidMount)

<img src="/assets/blog/javaScript/web-optimization15.png" width="100%" alt="post image"/>

```js
useEffect(() => {
    const Component = import('./components/ImageModal')
}, [])
```

지금은 단일 컴포넌트를 미리 import 하지만 여러 컴포넌트를 Preload해줘야 할 때는

```js
function lazyWithPreload(importFunction){
    const Component = React.lazy(importFunction)
    Component.preload = importFunction
    return Component
}

const LazyImageModal = lazyWithPreload(() => import('./components/ImageModal'))
```

```js
useEffect(() => {
    LazyImageModal.preload()
}, [])
```

처럼 사용할 수 있다.

#### **\- 이미지 Preload**

**new Image()**

```js
useEffect(() => {
    LazyImageModal.preload()

    const img = new Image()
    img.src = 'url'
}, [])
```

주의할점은 이미지는 모듈과 다르게 필요할 때 마다 그때그때 매번 보내기 때문에

사용하는 이미지에 캐시가 제대로 걸려있는지 확인할 필요가 있다.
4:T2416,

####
**[Svelte vs React: Ending the Debate](https://massivepixel.io/blog/svelte-vs-react/ "Svelte vs React: Ending the Debate")를 읽으며 정리한 글입니다.**

---

## 리액트

리액트는 페이스북에서 자체적으로 사용하기 위해 만든 라이브러리이며, 지금도 페이스북에서 관리하고 있다.

처음 접하는 사람도 배우기가 쉽고, 개발속도도 빠르며 많은 개발자들이 사용하는 만큼 참고할 만한 사례들이 많다.

또 가장 큰 특징은 재사용이 가능한 컴포넌트를 사용해 인터페이스를 구성하고, Virtual DOM을 사용해 앱의 성능을 향상시킨다는 것이다.

---

### 스벨트

스벨트는 최근에 등장한 언어이고, 리액트, 뷰 등의 기존 프레임워크 및 라이브러리를 보완하고자 2016년에 출시되었다.

Rich Harris가 개발했으며, 스벨트의 멤버들이 관리하고, 현재 스포티파이, 어베스트, 등의 회사에서 사용하고 있다.

스벨트의 공식사이트에서는 프레임워크라 소개하고 있지만 사실 컴파일러와 유사하다.

가볍고 빠른 앱을 만들기 위해 가능한 적은 양의 JS코드를 생성하고 적절한 최적화를 보장한다.

---

\- 등장 배경

리치 해리스는 템플릿 기반 UI 라이브러리인 리액티브의 개발자다. 해리스는 이 언어를 그닥 좋아하지 않았고, JS는 덩치가 커 모바일 환경에서는 부담이 크고 치명적인 단점이 있으며 이를 해결하지 못했기 때문이다.

### 스벨트와 리액트의 차이점

<img src="/assets/blog/javaScript/svelte.png" width="100%" alt="post image"/>
<img src="/assets/blog/javaScript/svelte(1).png" width="100%" alt="post image"/>

## 스벨트의 장점

#### 1\. 스벨트가 더 성능이 좋다.

스벨트는 **리액트, 뷰, 앵귤러 보다 더 좋은 성능**을 보여준다.

속도, 로딩, 메모리 등 모든 테스트에서 스벨트가 우위에 있다.

그 이유는 스벨트가 런타임이 아닌 빌드 타임에 애플리케이션 코드를 해석하기 때문이다.

또 HTML, CSS, JS가 최적화된 작은 번들로 컴파일이 되기 때문에 스벨트는 앱 비즈니스 로직 처리에만 신경쓰면 된다.

다른 프레임워크는 브라우저가 무거운 작업을 수행할 수 밖에 없도록 강제하므로 모든 부분에서 느려진다.

또 가장 큰 이유는 Virtual DOM이 없다는 것이다.

#### 2\. 스벨트는 Virtual DOM을 비교하지 않는다.

리액트에서는 Virtual DOM을 사용해 좋은 성능을 제공했고, 뷰도 이것을 보고 큰 영향을 받았다.

여기서 Virtual DOM(가상 돔)이란 사용자 인터페이스에서 발생한 모든 변경 사항에 대한 문서 객체 모델(Document Object Model)을 메모리에 유지하는 **가상 임시 저장소**이다.

실제 DOM을 사용하면 각각의 변경 사항이 발생할 때마다 DOM이 이를 반영하기 때문에 애플리케이션의 속도가 느려질 수 밖에 없다.

반면에 가상 DOM은 실제 DOM의 변경사항을 업데이트하고 렌더링하는 가장 효율적인 방법을 찾을 때까지 해당 프로세스를 지연시킨다.

이를 **조정(reconciliation) 프로세스 또는 비교(diffing)**라고 한다.

스벨트는 꼭 가상 DOM을 사용해야만 뛰어난 성능을 달성할 수 있다라는 점에 동의하지 않았고, 이를 증명했다.

#### 3\. 스벨트가 더 반응이 뛰어나다.

리액트는 선언적(declarative) 언어로써 어떠한 결과를 얻기 위해 각 단계를 모두 정의하는 대신에 원하는 결과만 지정하고 나머지는 리액트가 알아서 처리한다.

그러나 값이 변경되었을때 자동으로 DOM에 반영하지 않는다. 리액트는 정해진 일정에 따라 컴포넌트를 업데이트 한다. setState, Hook을 사용하지 않으면 제대로 반영되지 않는다.

스벨트도 이와 비슷하게 동작하지만 업데이트 명령을 받았을 때 동작한다. 그전까지는 발생한 모든 변경 사항이 한번에 처리된다.

그러나 고려해야할 부분은 **반응형 선언문과 변수**이다. 반응형 선언문(reactive delaration)은 업데이트가 발생하는 동안 자동으로 로직을 다시 계산하는 역할을 한다. 그리고 반응형 변수는 일단 선언하면, 변경이 발생할 때마다 다른 변수들도 자동으로 변경한다. 이는 $ 기호를 추가하는 것 만으로 쉽게 가능하다.

#### 4\. 스벨트의 컴포넌트는 약간 다르게 처리된다.

우선 스벨트는 컴포넌트를 내보내기 위해 **아무런 동작도 할 필요가 없다**. 스벨트가 자동으로 export해주기 때문이다. 이에 반해 리액트에서는 이를 수동으로 수행해야 된다.

또 스벨트는 **스타일 태그에서 컴포넌트의 범위를 지정**하므로 유연한 스타일 지정을 할 수 있다.

또 컴파일 단계에서 생성하므로 고유한 클래스를 작성하는데 애쓸 필요가 없다.

#### 5\. 스벨트에는 외부 라이브러리가 필요하지 않다.

리액트는 뷰 영역에 초점을 맞춘 가벼운 라이브러리이며, 상태관리나 애니메이션을 구현하려면 외부 라이브러리를 사용해야 한다.

이것이 꼭 나쁜것은 아니며 기능이 거의 없는 소규모 프로젝트의 경우에는 완벽할 수 있다.

그러나 스벨트에는 앱의 크기를 늘리지 않으면서도 효과, 전환, 애니메이션 등이 내장되어 있어 필요한 부분만 불러오면 된다.

또 스벨트는 다음과 같이 **상태 관리**를 할 수 있다.

-   **컨텍스트 API**: 컴포넌트가 서로 통신하며 데이터를 전달 할 때
-   **스벨트 스토어(Svelte Store)**: 컴포넌트가 대량의 데이터 전달하지 않고 통신해야 할 때
-   **쓰기 가능 저장소(Writable Store)**: 객체가 여러 컴포넌트에 접근해야 할 때
-   **읽기 가능 저장소(Readable Store)**: 사용자가 데이터를 조작하는 것을 원하지 않을 때


#### 6\. 스벨트가 더 가볍다.

GZIPPED(압축된) 버전의 리액트는 **42.2KB**(ReactDOM포함), 스벨트는 **1.6KB** 이다.

#### 7\. 스벨트는 더 빠른 웹 개발을 제공한다.

리액트의 개발 속도는 너무 빠르다 못해 이를 단점 중 하나로 인용되기도 한다.

하지만 스벨트의 개발 속도는 이보다 더 빠르다.

컴파일을 통해 생성된 코드는 리액트보다 짧고 읽기도 쉽다. 더 적은 수의 코드로 비슷한 결과를 얻어 낼 수 있으며, 이는 유지보수와 디버깅이 더 쉬워진다는 것을 의미한다.

#### 8\. 스벨트가 더 배우기 쉽다.

리액트와 스벨트 둘 다 HTML, CSS, JS에 대한 지식이 필요하다.

그러나 리액트에서는 JS에 대한 XML과 유사한 **JSX**를 배워야하지만, 스벨트는 더 쉬운 구문을 사용해 이해하기 쉬운 **자체 템플릿 언어**를 가지고 있다.

## 스벨트의 단점

#### 1\. 커뮤니티 규모가 작다.

리액트는 많은 사용과 큰 인기로 커뮤니티 규모도 크고 많은 무료 강좌와 가이드 등을 쉽게 구할 수 있고, 개발자 도구(React Revdloper, Redux DevTools 등) 생산성 향상에 도움을 주는 도구들이 많이있다.

그러나 스벨트는 리액트 규모만큼의 커뮤니티와 기술 지원을 기대하기 어렵다.

특히 **플러그인, 통합, IDE에 대한 부족한 지원**이 가장 큰 장애물이고, 문제가 발생하면 사용자에게 도움을 주지 못할 수도 있다.

#### 2\. 스벨트는 기업이 지원하지 않는다.

리액트는 페이스북이 지원하고 있고, 페이스북에서 직접 사용할 목적으로 만들고 관리를 하고 있다.

또 페이스북은 리액트의 지속적인 업데이트와 유지, 발전을 하기위한 자금을 가지고 있다. 이는 리액트에 미래에 대해 크게 걱정할 필요가 없다는 것을 의미한다.

하지만 스벨트는 미래가 명확하지 않다. 작은 커뮤니티에서 유지 관리를 하고 있지만, 그들의 열정이 얼마나 오래갈지는 아무도 알 수 없다.

또 스벨트에서 영감을 받은 또 다른 언어가 등장해 이 자리를 대체 할 수도 있다.

#### 3\. 스벨트는 대규모 웹에 거의 사용되지 않는다.

스벨트는 최근에서야 대기업 애플리케이션에 규모를 지원하도록 성장했다. 이는 스벨트의 사용 사례가 많지 않다는걸 의미한다.

## 결론

스벨트는 많은 것을 제공한다.

크기, 효율적은 코드, 빠른 성능으로 리액트, 뷰 또는 앵귤러에 강한 경쟁자로 보일 수 있다.

하지만 스벨트는 아직 갈 길이 멀다. 지금까지는 인터넷 연결이 낮거나, 블로그, 포트폴리오 등 단순히 개인 웹사이트를 만드는 단일 페이지 애플리케이션을 구축하는데 사용하는 것이 좋다.

또 큰 회사들의 기술 스택을 스벨트로 교체하기에는 많은 시간이 필요할 것이며 스벨트의 개발자들의 수요 또한 거의 없다.
5:T1085,
# 렌더링 최적화

### 1\. 컴포넌트를 맵핑할때는 key값으로 Index를 사용하지 말자

리액트에서 컴포넌트를 맵핑할 때에는 고유 Key값을 부여해야한다.

지금까지는 거의 Index를 고유한 Key값으로 사용했는데, 안좋은 습관인걸 알게됐다.

배열 중간에 어떤 요소가 삽입되게 된다면, 그 이후의 요소들은 전부 Index가 변경되기 때문에 Key값도 변경될 뿐만 아니라 리마운트가 실행된다.

또 이렇게 자주 Key값이 변경되게 된다면 서로 꼬이게 되는 버그도 발생할 수 있다.

하지만 무조건 사용하면 안되는 것은 아니다.

-   추가, 수정, 삭제 없이 단순히 렌더링만 하는 경우
-   unique한 값이 없을 경우
-   정렬이나 필터 요소가 없는 경우

### 2\. state는 어디에 선언해야 될까

리액트는 특정 state나 Props가 변경되게 되면 선언된 컴포넌트에서 그 하위 컴포넌트들 까지 모두다 리렌더링이 된다.

그렇기 때문에 state를 어디에 선언할지 잘 설계만 하더라도 불필요한 리렌더링을 막을 수 있다.

또 객체 타입의 state는 최대한 쪼개어서 선언해 사용하는게 좋다.

객체가 크고 복잡한 경우에 그 중 일부만 사용하더라도 관련된 모든 컴포넌트가 리렌더링 될것이다.

### 3\. useState의 함수형 업데이트

setState를 사용할때 새로운 상태를 파라미터로 넣어주는 대신에, 상태 업데이트를 어떻게 할지 정의해 주는 업데이트 함수를 넣을 수 있다.

이렇게 하면 useCallback을 사용할 때 두 번째 파라미터로 넣는 배열에 값을 넣어주지 않아도 된다.

```javascript
// 기존
  const onIncrease = useCallback(() => {
    setNumber(number + 1);
  }, [number]);


// 함수형 업데이트
  const onIncrease = useCallback(() => {
    setNumber((number) => number + 1);
  }, []);
```

### 4.Input Onchange 최적화

보통 Input 태그에 onChange를 사용해 글을 입력하면 타이핑을 할 때마다 컴포넌트가 랜더링이 된다.

이때 useMemo를 사용해주면 렌더링을 막을 수 있다.

```javascript
import React, { useState } from "react";

function InputSample() {
  const [text, setText] = useState("");
  const [count, setCount] = useState("");

  const onChange = (e) => {
    setText(e.target.value);
  };

  const onCount = () => {
    console.log("카운트..");
    return count;
  };

  const outCount = onCount();

  return (
    <div>
      <input onChange={onChange} value={text} />

      <div>
        <b>값: {text}</b>
        <b>{outCount}</b>
      </div>
    </div>
  );
}

export default InputSample;
```


```javascript
{...}
  const onChange = (e) => {
    setText(e.target.value);
  };

  const onCount = () => {
    console.log("카운트..");
    return count;
  };

  const outCount = useMemo(() => onCount(), [count]);

  return (
{...}
)
```


### 5\. memo, useMemo, useCallback

#### \- memo

React.memo는 Hook이 아니기 때문에 클래스형에서도 사용할 수 있다.

memo를 사용해 컴포넌트의 Props가 바뀌지 않았다면, 리렌더링하지 않도록 설정해 성능을 최적화 할 수 있다.

```javascript
import React, { memo } from "react";

function InputSample({ user }) {
  console.log("Text component render");
  return (
    <div>
      <b>{user?.id}</b>
      <b>{user?.name}</b>
      <b>{user?.age}</b>
    </div>
  );
}

export default memo(InputSample);
```

#### \- useMemo, useCallback

위에서 사용한 onCount의 함수가 간단한게 아니라 크고 복잡해 계산하는데 오래 걸리는 함수라고 가정한다면, 위 컴포넌트는 리렌더링 될 때마다 큰 계산을 계속 할 것이다.

useMemo \[\] 디펜던시에 데이터가 변할 때마다 함수를 실행할 수 있도록 count를 넣어주면 위 count가 변할 때마다 위 함수를 실행하게 된다.

useCallback도 비슷한 방식으로 작동 된다.

useMemo는 리턴되는 값을 memoize 시키는 반면에, useCallback은 함수 선언을 memoize 한다.

```javascript
  const addUser = useCallback(() => {
    {...}
  }, [users]);
```
6:T1f82,
[리액트 문서](https://beta.reactjs.org/)를 정독하며 정리한 글
영어문서라 조금 힘들었다...

## 목업으로 시작

다음과 같은 데이터를 받아오는 JSON API가 있다고 가정해보자.

```json
[
  { "category": "Fruits", "price": "$1", "stocked": true, "name": "Apple" },
  { "category": "Fruits", "price": "$1", "stocked": true, "name": "Dragonfruit" },
  { "category": "Fruits", "price": "$2", "stocked": false, "name": "Passionfruit" },
  { "category": "Vegetables", "price": "$2", "stocked": true, "name": "Spinach" },
  { "category": "Vegetables", "price": "$4", "stocked": false, "name": "Pumpkin" },
  { "category": "Vegetables", "price": "$1", "stocked": true, "name": "Peas" }
]
```

-   목업
<img src="https://beta.reactjs.org/images/docs/s_thinking-in-react_ui.png" alt='mock' />

### 1, UI를 컴포넌트로 나누기
<img src="https://beta.reactjs.org/images/docs/s_thinking-in-react_ui_outline.png" alt="ui" />

1.  FilterableProductTable (회색)은 전체 앱을 포함합니다.
2.  SearchBar (파란색)은 사용자 입력을 받습니다.
3.  ProductTable (라벤더)는 사용자 입력에 따라 목록을 표시하고 필터링합니다.
4.  ProductCategoryRow (녹색)은 각 범주에 대한 제목을 표시합니다.
5.  ProductRow (노란색)은 각 제품에 대한 행을 표시합니다.

이를 계층별로 나누면

-   FilterableProductTable
-   SearchBar
-   ProductTable
-   ProductCategoryRow
-   ProductRow

위와같이 구성된다.



### 2\. React 정적 빌드

이제 위와같은 계층구조를 만들고 앱을 구현할 차례이다.
일반적으로 정적페이지를 만들고 상호작용되는 기능들을 추가하는게 더 쉬울 수 있다.
또 보통은 FilterableProductTable(가장 상위) 부터 컴포넌트에서 하향식으로 작업하는게 쉽지만, 큰 프로젝트에서는 반대로 ProductRow 부터 상향식으로 작업하는게 쉬울 수 있다.

```javascript
function ProductCategoryRow({ category }) {
  return (
    <tr>
      <th colSpan="2">
        {category}
      </th>
    </tr>
  );
}
```

```javascript
function ProductRow({ product }) {
  const name = product.stocked ? product.name :
    <span style={{ color: 'red' }}>
      {product.name}
    </span>;

  return (
    <tr>
      <td>{name}</td>
      <td>{product.price}</td>
    </tr>
  );
}
```

```javascript
function ProductTable({ products }) {
  const rows = [];
  let lastCategory = null;

  products.forEach((product) => {
    if (product.category !== lastCategory) {
      rows.push(
        <ProductCategoryRow
          category={product.category}
          key={product.category} />
      );
    }
    rows.push(
      <ProductRow
        product={product}
        key={product.name} />
    );
    lastCategory = product.category;
  });

  return (
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Price</th>
        </tr>
      </thead>
      <tbody>{rows}</tbody>
    </table>
  );
}
```

```javascript
function SearchBar() {
  return (
    <form>
      <input type="text" placeholder="Search..." />
      <label>
        <input type="checkbox" />
        {' '}
        Only show products in stock
      </label>
    </form>
  );
}
```

```javascript
function FilterableProductTable({ products }) {
  return (
    <div>
      <SearchBar />
      <ProductTable products={products} />
    </div>
  );
}
```

```javascript
const PRODUCTS = [
  {category: "Fruits", price: "$1", stocked: true, name: "Apple"},
  {category: "Fruits", price: "$1", stocked: true, name: "Dragonfruit"},
  {category: "Fruits", price: "$2", stocked: false, name: "Passionfruit"},
  {category: "Vegetables", price: "$2", stocked: true, name: "Spinach"},
  {category: "Vegetables", price: "$4", stocked: false, name: "Pumpkin"},
  {category: "Vegetables", price: "$1", stocked: true, name: "Peas"}
];
```

```javascript
export default function App() {
  return <FilterableProductTable products={PRODUCTS} />;
}
```




### 3\. 최소화되고 완전한 state 찾기

state를 구조화 하는데 가장 중요한 원칙은 DRY(Don't repeat yourself) 중복배제 이다.
이제 위 애플리케이션의 모든 데이터를 쪼개서 생각해 보자.
제품의 원래 목록
사용자가 입력한 검색 input
체크박스의 값
필터링된 제품 목록
Q. 다음 중 상태는 무엇인가?
시간이 지나도 변하지 않는다면 state가 아니다.
부모를 통해 props로 전달되면 state가 아니다.
기존 컴포넌트의 props나 state기반으로 계산되면 state가 아니다. (이 부분은 해석이 조금 이해되지 않는다.)
다시 살펴 보자.
제품의 원래 목록은 props로 전달되므로 state가 아니다.
검색 input는 시간이 지남에 따라 변경되고 아무 것도 계산할 수 없기 때문에 상태로 보인다.
체크박스의 값은 시간이 지남에 따라 변경되고 아무 것도 계산할 수 없기 때문에 상태로 보인다.
필터링된 제품 목록은 원래 제품 목록을 가져와서 검색 input과 체크박스의 값에 따라 필터링하여 계산할 수 있기 때문에 상태가 아니다.




### 4\. state가 어디에 있어야 하는지 확인

React는 단방향 데이터 흐름을 사용하여 상위 컴포넌트에서 하위 컴포넌트로 컴포넌트 계층 구조를 따라 데이터를 전달한다.
위에서 아래로!

-   애플리케이션의 각 state에 대해:

1.  state를 기반으로 무언가를 렌더링 하는 모든 컴포넌트를 확인한다.
2.  가장 가까운 부모 컴포넌트를 찾는다.

-   state가 어디에 있어야 하는지 결정:

1.  state를 바로 위 부모 컴포넌트에 놓을 수 있다.
2.  또한 state를 공통된 부모 컴포넌트의 부모 컴포넌트에 놓을 수 있다.
3.  state를 놓을 곳을 찾을 수 없으면 state를 유지하기 위한 새 컴포넌트를 만들고 최상위 컴포넌트 어딘가에 추가한다.
4.  이전 단계에서 이 애플리케이션에서 검색 기능과 체크박스의 두 가지 상태를 찾았고, 이 예시 에서는 항상 함께 나타나므로 단일 상태로 생각하는 것이 더 쉽다.

-   state를 사용하는 컴포넌트 찾기:

1.  ProductTable의 state(검색 및 체크박스 값)를 기반으로 제품 목록을 필터링해야 한다.
2.  SearchBar의 state(검색 및 체크박스 값)를 표시해야 한다.

-   공통되는 상위 컴포넌트 찾기: 두 컴포넌트가 공유하는 첫 번째 부모 컴포넌트는 FilterableProductTable.(두 컴포넌트의 상위 부모 컴포넌트)
-   state가 있는 위치 결정 : 검색 및 체크박스의 state 값을 FilterableProductTable(두 컴포넌트의 상위 부모 컴포넌트)에서 유지해야한다.
-   따라서 state는 FilterableProductTable(두 컴포넌트의 상위 부모 컴포넌트)에 있어야 한다.

```javascript
function FilterableProductTable({ products }) {
  const [filterText, setFilterText] = useState('');
  const [inStockOnly, setInStockOnly] = useState(false);
```

그런 다음 props로 내려준다

```javascript
<div>
  <SearchBar
    filterText={filterText}
    inStockOnly={inStockOnly} />
  <ProductTable
    products={products}
    filterText={filterText}
    inStockOnly={inStockOnly} />
</div>
```


### 5\. 반대방향의 데이터 흐름 추가하기

마지막으로는 SearchBar, ProductTable에서 입력받은 state를 FilterableProductTable로 다시 전달해 줘야한다.

```javascript
function FilterableProductTable({ products }) {
  const [filterText, setFilterText] = useState('');
  const [inStockOnly, setInStockOnly] = useState(false);

  return (
    <div>
      <SearchBar
        filterText={filterText}
        inStockOnly={inStockOnly}
        onFilterTextChange={setFilterText}
        onInStockOnlyChange={setInStockOnly} />
```

```javascript
// SearchBar

<input
  type="text"
  value={filterText}
  placeholder="Search..."
  onChange={(e) => onFilterTextChange(e.target.value)} />
```


7:T1c8d,
## React Hook

React로 개발할 땐 클래스형 컴포넌트 보다 React 16.8 부터 도입된 Hook 기반 함수형 컴포넌트를 더 선호하여 개발하는 것 같다.

기존 클래스형 컴포넌트는 여러 단계의 상속과 복잡성, 오류 등이 많았지만 Hook이 도입되면서 클래스형 컴포넌트가 가지고 있는 기능을 모두 사용할 수 있음은 물론이고 복잡성과 재사용성의 단점들까지도 해결됐다.

---

## 클로저(Closure)

Hook의 핵심은 JS의 클로저이다.
클로저는..봐도봐도 잘 이해가 가지 않는다ㅠㅠ

`클로저 = 함수 + 함수를 둘러싼 환경`
이라고 말할 수 있는데, 자바스크립트는 함수 안에서도 함수를 선언할 수 있다.
먼저 선언된 함수를 외부함수, 이후에 선언된 함수를 내부함수라 한다면 기본적으로 내부함수는 외부함수의 요소에 접근이 가능하다.
즉 외부함수의 변수에 내부함수의 변수가 접근 할 수 있는 자바스크립트의 메커니즘이다.

```javascript
function outerFn() {
  let outerVar = 'outer'
  console.log(outerVar)

  //클로저 함수
  function innerFn() {
    let innerVar = 'inner'
    console.log(innerVar)
  }
  //클로저 함수 안에서는
  //지역변수(innerVar)
  //외부함수의 변수(outerVar)
  //전역변수(globalVar)
  //접근이 모두 가능하다.
  return innerFn
}
let globalVar = 'global'
let innerFn = outerFn()
innerFn()
```

---

## useState

```javascript
function useState(initVal) {
  let _val = initVal
  const state = _val
  const setState = newVal => {
    _val = newVal
  }
  return [state, setState]
}
const [count, setCount] = useState(1)
console.log(count) // 1
setCount(2)
console.log(count) // 1 (?)
```

위 함수에서 `count`는 한번 가져오고 끝난 값이기 때문에 즉각적으로 바뀌지 않는다.
만약 `const state = _val` 부분을 함수로 바꾸고, 값을 쓰는게 아닌 호출해주는 식으로 바꾼다면 호출할 때마다 값을 가져오기 때문에 `setCount`가 반영된 값을 가져올 수 있다.

```javascript
// useState 안에서
// ...
const state = () => _val
// ...
const [count, setCount] = useState(1)
console.log(count()) // 1
setCount(2)
console.log(count()) // 2
```

`state`는 상단에 정의된 `_val`를 반환하고, `setState`는 전달 된 매개변수 `newVal`를 지역 변수로 설정한다.

---

### 함수형 컴포넌트에서 사용하기

```javascript
const React = (function() {
  function useState(initVal) {
    let _val = initVal
    const state = _val
    const setState = newVal => {
      _val = newVal
    }
    return [state, setState]
  }
  function render(Component) {
    const C = Component()
    C.render()
    return C
  }
  return { useState, render }
})()
function Component() {
  const [count, setCount] = React.useState(1)
  return {
    render: () => console.log(count),
    click: () => setCount(count + 1),
  }
}
// 아직까진 중간 과정이므로 제대로 동작하지 않는다.
var App = React.render(Component)
App.click()
var App = React.render(Component)
```

모듈패턴을 이용해 `React`라는 네임스페이스에 `useState`를 집어넣는다.
그리고 DOM을 사용하진 않지만 가상의 컴포넌트를 만들어 `useState` 훅을 가져다 쓰는 방식이다.

여기서 `count`가 제대로 동작하게 만들기 위해 `_val`로 쓰고 있던 변수를 `React` 내부로 끌어올리면 랜더링 이후 클릭해도 작동한다.

```javascript
const React = (function() {
  let _val
  function useState(initVal) {
    const state = _val || initVal
    // ...
  }
  // ...
})()
var App = React.render(Component) // 1
App.click()
var App = React.render(Component) // 2
App.click()
var App = React.render(Component) // 3
App.click()
var App = React.render(Component) // 4
```

---

### 여러 개의 훅

하지만 실제로 하나의 컴포넌트에서 여러 상태를 관리하기 위해 여러 훅을 사용하는데. `_val` 하나에 의존한 지금 상태로 `useState`를 두번 호출하게되면

```javascript
function Component() {
  const [count, setCount] = React.useState(1)
  const [text, setText] = React.useState('apple')
  return {
    render: () => console.log({ count, text }),
    click: () => setCount(count + 1),
    type: word => setText(word),
  }
}
var App = React.render(Component) // {count: 1, text: 'apple'}
App.click()
var App = React.render(Component) // {count: 2, text: 2}
App.type('banana')
var App = React.render(Component) // {count: 'banana', text: 'banana'}
```

중간에 값이 덮어씌워 진다. 이를 관리 하려면 각 값별로 배열에 담아 다루면 된다.

```javascript
const React = (function() {
  let hooks = []
  let idx = 0
  function useState(initVal) {
    const state = hooks[idx] || initVal
    const _idx = idx // 이 훅이 사용해야 하는 인덱스를 가둬둔다.
    const setState = newVal => {
      hooks[_idx] = newVal
    }
    idx++ // 다음 훅은 다른 인덱스를 사용하도록 한다.
    return [state, setState]
  }
  function render(Component) {
    idx = 0 // 랜더링 시 훅의 인덱스를 초기화한다.
    const C = Component()
    C.render()
    return C
  }
  return { useState, render }
})()
```

여기까지보면 왜 Hook에 기본 규칙이 있는지 알 수 있다.

1.  최상위(Top Level)에서만 Hook을 호출
2.  오직 React 함수 내에서 Hook을 호출

---

## useEffect

`useEffect`를 사용하면 컴포넌트를 화면에 그린 후 실행될 함수를 정의할 수 있다.
또 매번 `render`했을 때 최초 한 번만 실행되며 매 업데이트마다 실행된다.

```javascript
function Component() {
  const [count, setCount] = React.useState(1)
  const [text, setText] = React.useState('apple')
  // 랜더링 시 최초에 한 번만 실행된다.
  // 배열 안에 관찰하고자 하는 상태를 전달하면 그 상태에 반응하여 콜백이 실행된다.
  React.useEffect(() => {
    console.log('side effect')
  }, [])
  // ...
}
```

```javascript
function useEffect(cb, depArray) {
  const oldDeps = hooks[idx] // 이미 저장되어있던 의존 값 배열이 있는지 본다.
  let hasChanged = true
  if (oldDeps) {
    // 의존 값 배열의 값 중에서 차이가 발생했는지 확인한다.
    // 실제로 리액트 구현체도 `Object.is` 로 값을 비교한다. 정확한 동작은 MDN 참고.
    hasChanged = depArray.some((dep, i) => !Object.is(dep, oldDeps[i]))
  }
  // 값이 바뀌었으니 콜백을 실행한다.
  if (hasChanged) {
    cb()
  }
  // useEffect도 훅의 일부분이다. hooks 배열에 넣어서 관리해준다.
  hooks[idx] = depArray
  idx++
}
```

위에 선언된 `React` 모듈 안에 `useEffect`함수를 정의한다.
두번째 인자로 넣어둔 의존배열(dependency array)을 관찰하며 값이 변하면 콜백을 실행하고, 그렇지 않으면 실행하지 않는다.

---

## 참조

위 글은 아래 두 블로그를 정독하며 정리하였습니다.

[Deep dive: How do React hooks really work?](https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/)

[Getting Closure on React Hooks](https://rinae.dev/posts/getting-closure-on-react-hooks-summary)
a:["page","4","d"]
0:["Lw08DNgYJb1rmMfBjZDd6",[[["",{"children":["page",{"children":[["page","4","d"],{"children":["__PAGE__?{\"page\":\"4\"}",{}]}]}]},"$undefined","$undefined",true],["",{"children":["page",{"children":[["page","4","d"],{"children":["__PAGE__",{},["$L1",["$","section",null,{"className":"flex flex-col-reverse md:relative md:flex-row","children":[["$","$L2",null,{"posts":{"posts":[{"content":"$3","data":{"title":"웹성능 최적화(1)","date":"$D2022-01-01T00:00:00.000Z","description":"웹성능 최적화1","category":"javaScript","titleImage":"/assets/postIcon/logo192.png"},"slug":"web-optimization"},{"content":"$4","data":{"title":"스벨트와 리액트","date":"$D2021-12-12T00:00:00.000Z","description":"스벨트와 리액트에 대해 정리한 글","category":"javaScript","titleImage":"/assets/postIcon/svelte-icon.webp"},"slug":"svelte-react"},{"content":"$5","data":{"title":"React 처럼 생각하기(2)","date":"$D2021-12-12T00:00:00.000Z","description":"리액트 문서 보며 정리","category":"javaScript","titleImage":"/assets/postIcon/logo192.png"},"slug":"thinking-in-react-2"},{"content":"$6","data":{"title":"React 처럼 생각하기","date":"$D2021-11-20T00:00:00.000Z","description":"리액트 문서 보며 정리","category":"javaScript","titleImage":"/assets/postIcon/logo192.png"},"slug":"thinking-in-react"},{"content":"$7","data":{"title":"React Hook의 동작","date":"$D2021-11-07T00:00:00.000Z","description":"React Hook의 동작에 대해","category":"javaScript","titleImage":"/assets/postIcon/logo192.png"},"slug":"react-hook"}],"total":35},"page":"4","category":"$undefined"}],["$","ul",null,{"className":"relative top-0 flex h-fit min-w-fit flex-row flex-wrap gap-[20px] py-[20px] pl-0 md:sticky md:top-[100px] md:flex-col md:flex-nowrap md:py-0 md:pl-[30px]","children":[["$","h2",null,{"className":"hidden text-[18px] font-bold md:inline","children":"Category"}],[["$","li","javaScript",{"children":["$","$L8",null,{"className":"text-gray700","href":"/blog/javaScript","children":"javaScript (32)"}]}],["$","li","study",{"children":["$","$L8",null,{"className":"text-gray700","href":"/blog/study","children":"study (2)"}]}],["$","li","til",{"children":["$","$L8",null,{"className":"text-gray700","href":"/blog/til","children":"til (1)"}]}]]]}]]}],null]]},["$","$L9",null,{"parallelRouterKey":"children","segmentPath":["children","page","children","$a","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$Lb",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},["$","$L9",null,{"parallelRouterKey":"children","segmentPath":["children","page","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$Lb",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},[null,["$","html",null,{"lang":"ko","suppressHydrationWarning":true,"children":[null,["$","$Lc",null,{"src":"https://www.googletagmanager.com/gtag/js?id=G-LFDRQZPCBN"}],["$","$Lc",null,{"id":"google-analytics","children":"\n          window.dataLayer = window.dataLayer || [];\n          function gtag(){dataLayer.push(arguments);}\n          gtag('js', new Date());\n \n          gtag('config', 'G-LFDRQZPCBN');\n        "}],["$","body",null,{"suppressHydrationWarning":true,"className":"__className_471caf","children":["$","$Ld",null,{"children":[["$","$e",null,{"fallback":null,"children":["$","$Lf",null,{"children":["$","$L10",null,{}]}]}],[["$","header",null,{"className":"sticky top-0 z-10 mx-auto my-0 h-[56px] border-b-[1px] border-b-gray200 bg-white px-[24px] py-0 dark:bg-darkBg01","children":["$","section",null,{"className":"m-auto flex h-full max-w-[970px] items-center justify-between","children":[["$","div",null,{"className":"flex items-center gap-[20px]","children":[["$","$L8",null,{"href":"/","children":["$","$L11",null,{"src":"/assets/icons/been-logo.svg","width":60,"height":56,"alt":"logo"}]}],["$","div",null,{"className":"flex items-center gap-[20px]","children":["$","$L8",null,{"href":"/about","children":"About"}]}]]}],["$","$e",null,{"fallback":null,"children":["$","$Lf",null,{"children":["$","$L12",null,{}]}]}]]}]}],["$","main",null,{"className":"mx-auto my-0 max-w-[970px] p-[16px]","children":["$","$L9",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$Lb",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":null}]}],["$","footer",null,{"className":"flex items-center justify-center pb-[16px] text-center text-[14px] text-gray600","children":"Copyright © Been."}]]]}]}]]}],null]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/f02a732008014100.css","precedence":"next","crossOrigin":""}]],"$L13"]]]]
13:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Been blog - 4"}],["$","meta","3",{"name":"description","content":"Been dev-note"}],["$","meta","4",{"name":"google-site-verification","content":"BirkRt7C7FYMLW96RbXad2EtPdcl0-_ti9xCRkCHa5U"}],["$","meta","5",{"name":"naver-site-verification","content":"58945b2bbe2fe86252fa8c7b204b40f6019920e9"}],["$","meta","6",{"property":"og:title","content":"Been blog - 4"}],["$","meta","7",{"property":"og:description","content":"Been dev-note - 4"}],["$","meta","8",{"property":"og:url","content":"https://wonbeenna.github.io/page/4"}],["$","meta","9",{"property":"og:site_name","content":"Been blog"}],["$","meta","10",{"property":"og:image","content":"https://wonbeenna.github.io/favicon.png"}],["$","meta","11",{"property":"og:image:width","content":"800"}],["$","meta","12",{"property":"og:image:height","content":"600"}],["$","meta","13",{"property":"og:image:alt","content":"Been blog"}],["$","meta","14",{"property":"og:type","content":"website"}],["$","meta","15",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","16",{"name":"twitter:title","content":"Been blog - 4"}],["$","meta","17",{"name":"twitter:description","content":"Been dev-note - 4"}],["$","meta","18",{"name":"twitter:image","content":"https://wonbeenna.github.io/favicon.png"}],["$","meta","19",{"name":"twitter:image:width","content":"800"}],["$","meta","20",{"name":"twitter:image:height","content":"600"}],["$","meta","21",{"name":"twitter:image:alt","content":"Been blog"}],["$","link","22",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"192x192"}],["$","meta","23",{"name":"next-size-adjust"}]]
1:null
